<!DOCTYPE HTML>
<html lang="en" class="navy sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>SwissArmyHammer Documentation</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="Complete guide to using SwissArmyHammer - the MCP server for managing prompts">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "navy";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>‚Üê</kbd> or <kbd>‚Üí</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('navy')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">SwissArmyHammer Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/wballard/swissarmyhammer" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="swissarmyhammer"><a class="header" href="#swissarmyhammer">SwissArmyHammer</a></h1>
<p><strong>The MCP server for managing prompts as markdown files</strong></p>
<p>SwissArmyHammer is a powerful Model Context Protocol (MCP) server that lets you manage AI prompts as simple markdown files. It seamlessly integrates with Claude Code and other MCP-compatible tools, providing a flexible and organized way to work with AI prompts.</p>
<h2 id="what-is-swissarmyhammer"><a class="header" href="#what-is-swissarmyhammer">What is SwissArmyHammer?</a></h2>
<p>SwissArmyHammer transforms how you work with AI prompts by:</p>
<ul>
<li><strong>üìÅ File-based prompt management</strong> - Store prompts as markdown files with YAML front matter</li>
<li><strong>üîÑ Live reloading</strong> - Changes to prompt files are automatically detected and reloaded</li>
<li><strong>üéØ Template variables</strong> - Use <code>{{variable}}</code> syntax for dynamic prompt customization</li>
<li><strong>‚ö° MCP integration</strong> - Works seamlessly with Claude Code and other MCP clients</li>
<li><strong>üóÇÔ∏è Organized hierarchy</strong> - Support for built-in, user, and local prompt directories</li>
<li><strong>üõ†Ô∏è Developer-friendly</strong> - Rich CLI with diagnostics and shell completions</li>
</ul>
<h2 id="key-features"><a class="header" href="#key-features">Key Features</a></h2>
<h3 id="-quick-setup"><a class="header" href="#-quick-setup">üöÄ Quick Setup</a></h3>
<p>Get started by installing with Cargo:</p>
<pre><code class="language-bash">cargo install --git https://github.com/wballard/swissarmyhammer.git swissarmyhammer-cli
</code></pre>
<p>This requires Rust 1.70+ to be installed. Get Rust from <a href="https://rustup.rs/">rustup.rs</a>.</p>
<h3 id="-simple-prompt-format"><a class="header" href="#-simple-prompt-format">üìù Simple Prompt Format</a></h3>
<p>Create prompts using familiar markdown with YAML front matter:</p>
<pre><code class="language-markdown">---
title: Code Review Helper
description: Helps review code for best practices and potential issues
arguments:
  - name: code
    description: The code to review
    required: true
  - name: language
    description: Programming language
    required: false
    default: "auto-detect"
---

# Code Review

Please review the following {{language}} code:

</code></pre>
<p>{{code}}</p>
<pre><code>
Focus on:
- Code quality and readability
- Potential bugs or security issues
- Performance considerations
- Best practices adherence
</code></pre>
<h3 id="-template-variables"><a class="header" href="#-template-variables">üéØ Template Variables</a></h3>
<p>Use template variables to make prompts dynamic and reusable:</p>
<ul>
<li><code>{{variable}}</code> - Required variables</li>
<li><code>{{variable:default}}</code> - Optional variables with defaults</li>
<li>Support for strings, numbers, booleans, and JSON objects</li>
</ul>
<h3 id="-built-in-diagnostics"><a class="header" href="#-built-in-diagnostics">üîß Built-in Diagnostics</a></h3>
<p>The <code>doctor</code> command helps troubleshoot setup issues:</p>
<pre><code class="language-bash">swissarmyhammer doctor
</code></pre>
<h2 id="use-cases"><a class="header" href="#use-cases">Use Cases</a></h2>
<p>SwissArmyHammer is perfect for:</p>
<ul>
<li><strong>Development Teams</strong> - Share and standardize AI prompts across your team</li>
<li><strong>Individual Developers</strong> - Organize your personal prompt library</li>
<li><strong>Content Creators</strong> - Manage writing and editing prompts</li>
<li><strong>Researchers</strong> - Organize domain-specific prompts and templates</li>
<li><strong>Students</strong> - Build a learning-focused prompt collection</li>
</ul>
<h2 id="architecture"><a class="header" href="#architecture">Architecture</a></h2>
<p>SwissArmyHammer follows a simple but powerful architecture:</p>
<pre><code>‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Claude Code   ‚îÇ‚óÑ‚îÄ‚îÄ‚ñ∫‚îÇ SwissArmyHammer  ‚îÇ‚óÑ‚îÄ‚îÄ‚ñ∫‚îÇ Prompt Files    ‚îÇ
‚îÇ   (MCP Client)  ‚îÇ    ‚îÇ   (MCP Server)   ‚îÇ    ‚îÇ (.md files)     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                              ‚îÇ
                              ‚ñº
                       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                       ‚îÇ  File Watcher    ‚îÇ
                       ‚îÇ (Auto-reload)    ‚îÇ
                       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
</code></pre>
<h2 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h2>
<p>Ready to get started? Check out our <a href="./installation.html">Installation Guide</a> or jump straight to creating <a href="./first-prompt.html">Your First Prompt</a>.</p>
<p>For integration with Claude Code, see our <a href="./claude-code-integration.html">Claude Code Integration</a> guide.</p>
<h2 id="community"><a class="header" href="#community">Community</a></h2>
<ul>
<li><strong>GitHub</strong>: <a href="https://github.com/wballard/swissarmyhammer">github.com/wballard/swissarmyhammer</a></li>
<li><strong>Issues</strong>: Report bugs and request features</li>
<li><strong>Discussions</strong>: Community Q&amp;A and sharing</li>
<li><strong>Contributing</strong>: See our <a href="./contributing.html">Contributing Guide</a></li>
</ul>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<p>SwissArmyHammer is open source software licensed under the MIT License. See the <a href="./license.html">License</a> page for details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<p>For complete installation instructions, see <a href="../../INSTALLATION.html">INSTALLATION.md</a>.</p>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<p>Before installing SwissArmyHammer, you need:</p>
<ul>
<li><strong>Rust 1.70 or later</strong> - Install from <a href="https://rustup.rs/">rustup.rs</a></li>
<li><strong>Git</strong> - For cloning the repository</li>
</ul>
<h2 id="path-configuration"><a class="header" href="#path-configuration">PATH Configuration</a></h2>
<p>Make sure <code>~/.cargo/bin</code> is in your PATH. Add this to your shell configuration file:</p>
<pre><code class="language-bash"># For bash (~/.bashrc or ~/.bash_profile)
export PATH="$HOME/.cargo/bin:$PATH"

# For zsh (~/.zshrc)
export PATH="$HOME/.cargo/bin:$PATH"

# For fish (~/.config/fish/config.fish)
set -gx PATH $HOME/.cargo/bin $PATH
</code></pre>
<h2 id="alternative-clone-and-build"><a class="header" href="#alternative-clone-and-build">Alternative: Clone and Build</a></h2>
<p>If you want to build from source or contribute to development:</p>
<pre><code class="language-bash"># Clone the repository
git clone https://github.com/wballard/swissarmyhammer.git
cd swissarmyhammer

# Build the CLI (debug mode for development)
cargo build

# Build optimized release version
cargo build --release

# Install from the local source
cargo install --path swissarmyhammer-cli

# Or run directly without installing
cargo run --bin swissarmyhammer -- --help
</code></pre>
<h2 id="future-installation-methods"><a class="header" href="#future-installation-methods">Future Installation Methods</a></h2>
<p>Pre-built binaries and package manager support are planned for future releases:</p>
<ul>
<li><strong>macOS</strong>: Homebrew formula</li>
<li><strong>Linux</strong>: DEB and RPM packages</li>
<li><strong>Windows</strong>: MSI installer and Chocolatey package</li>
<li><strong>crates.io</strong>: Published crate for <code>cargo install swissarmyhammer-cli</code></li>
</ul>
<p>Check the <a href="https://github.com/wballard/swissarmyhammer/releases">releases page</a> for updates.</p>
<h2 id="verification"><a class="header" href="#verification">Verification</a></h2>
<p>After installation, verify that SwissArmyHammer is working correctly:</p>
<pre><code class="language-bash"># Check version
swissarmyhammer --version

# Run diagnostics
swissarmyhammer doctor

# Show help
swissarmyhammer --help

# List available commands
swissarmyhammer list
</code></pre>
<p>The <code>doctor</code> command will check your installation and provide helpful diagnostics if anything needs attention.</p>
<h2 id="shell-completions"><a class="header" href="#shell-completions">Shell Completions</a></h2>
<p>Generate and install shell completions for better CLI experience:</p>
<pre><code class="language-bash"># Bash
swissarmyhammer completion bash &gt; ~/.local/share/bash-completion/completions/swissarmyhammer

# Zsh (add to fpath)
swissarmyhammer completion zsh &gt; ~/.zfunc/_swissarmyhammer

# Fish
swissarmyhammer completion fish &gt; ~/.config/fish/completions/swissarmyhammer.fish

# PowerShell
swissarmyhammer completion powershell &gt;&gt; $PROFILE
</code></pre>
<p>Remember to reload your shell or start a new terminal session for completions to take effect.</p>
<h2 id="updating"><a class="header" href="#updating">Updating</a></h2>
<p>To update SwissArmyHammer to the latest version:</p>
<pre><code class="language-bash"># Update from git repository
cargo install --git https://github.com/wballard/swissarmyhammer.git swissarmyhammer-cli --force
</code></pre>
<p>The <code>--force</code> flag will overwrite the existing installation.</p>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<p>Once installed, continue to the <a href="./quick-start.html">Quick Start</a> guide to set up SwissArmyHammer with Claude Code and create your first prompt.</p>
<h2 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h2>
<h3 id="common-issues"><a class="header" href="#common-issues">Common Issues</a></h3>
<p><strong>Command not found</strong>: Make sure <code>~/.cargo/bin</code> is in your PATH.</p>
<p><strong>Build failures</strong>: Ensure you have Rust 1.70+ installed and try updating Rust:</p>
<pre><code class="language-bash">rustup update
</code></pre>
<p><strong>Permission errors</strong>: Don‚Äôt use <code>sudo</code> with cargo install - it installs to your user directory.</p>
<p>For more help, check the <a href="./troubleshooting.html">Troubleshooting</a> guide or run:</p>
<pre><code class="language-bash">swissarmyhammer doctor
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quick-start"><a class="header" href="#quick-start">Quick Start</a></h1>
<p>Get up and running with SwissArmyHammer in just a few minutes.</p>
<h2 id="prerequisites-1"><a class="header" href="#prerequisites-1">Prerequisites</a></h2>
<p>Before you begin, make sure you have:</p>
<ul>
<li>SwissArmyHammer installed (see <a href="./installation.html">Installation</a>)</li>
<li>Claude Code (or another MCP-compatible client)</li>
</ul>
<h2 id="step-1-verify-installation"><a class="header" href="#step-1-verify-installation">Step 1: Verify Installation</a></h2>
<p>First, check that SwissArmyHammer is properly installed:</p>
<pre><code class="language-bash">swissarmyhammer --version
</code></pre>
<p>Run the doctor command to check your setup:</p>
<pre><code class="language-bash">swissarmyhammer doctor
</code></pre>
<p>This will check your system and provide recommendations if anything needs attention.</p>
<h2 id="step-2-configure-claude-code"><a class="header" href="#step-2-configure-claude-code">Step 2: Configure Claude Code</a></h2>
<p>Add SwissArmyHammer to your Claude Code MCP configuration:</p>
<h3 id="find-your-config-file"><a class="header" href="#find-your-config-file">Find Your Config File</a></h3>
<p>The Claude Code configuration file is located at:</p>
<ul>
<li><strong>macOS</strong>: <code>~/Library/Application Support/Claude/claude_desktop_config.json</code></li>
<li><strong>Windows</strong>: <code>%APPDATA%\Claude\claude_desktop_config.json</code></li>
<li><strong>Linux</strong>: <code>~/.config/Claude/claude_desktop_config.json</code></li>
</ul>
<h3 id="add-the-configuration"><a class="header" href="#add-the-configuration">Add the Configuration</a></h3>
<p>Create or edit the configuration file with the following content:</p>
<pre><code class="language-json">{
  "mcpServers": {
    "swissarmyhammer": {
      "command": "swissarmyhammer",
      "args": ["serve"]
    }
  }
}
</code></pre>
<p>If you already have other MCP servers configured, just add the <code>swissarmyhammer</code> entry to your existing <code>mcpServers</code> object.</p>
<h2 id="step-3-create-your-prompt-directory"><a class="header" href="#step-3-create-your-prompt-directory">Step 3: Create Your Prompt Directory</a></h2>
<p>Create a directory for your prompts:</p>
<pre><code class="language-bash">mkdir -p ~/.swissarmyhammer/prompts
</code></pre>
<p>This is where you‚Äôll store your custom prompts. SwissArmyHammer will automatically watch this directory for changes.</p>
<h2 id="step-4-create-your-first-prompt"><a class="header" href="#step-4-create-your-first-prompt">Step 4: Create Your First Prompt</a></h2>
<p>Create a simple prompt file:</p>
<pre><code class="language-bash">cat &gt; ~/.swissarmyhammer/prompts/helper.md &lt;&lt; 'EOF'
---
title: General Helper
description: A helpful assistant for various tasks
arguments:
  - name: task
    description: What you need help with
    required: true
  - name: style
    description: How to approach the task
    required: false
    default: "friendly and concise"
---

# Task Helper

Please help me with: {{task}}

Approach this in a {{style}} manner. Provide clear, actionable advice.
EOF
</code></pre>
<h2 id="step-5-test-the-setup"><a class="header" href="#step-5-test-the-setup">Step 5: Test the Setup</a></h2>
<ol>
<li>
<p><strong>Restart Claude Code</strong> to pick up the new MCP server configuration.</p>
</li>
<li>
<p><strong>Open Claude Code</strong> and start a new conversation.</p>
</li>
<li>
<p><strong>Try using your prompt</strong>: In Claude Code, you should now see SwissArmyHammer prompts available in the prompt picker.</p>
</li>
<li>
<p><strong>Use the built-in prompts</strong>: SwissArmyHammer comes with several built-in prompts you can try right away:</p>
<ul>
<li><code>help</code> - Get help with using SwissArmyHammer</li>
<li><code>debug-error</code> - Debug error messages</li>
<li><code>code-review</code> - Review code for issues</li>
<li><code>docs-readme</code> - Generate README files</li>
</ul>
</li>
</ol>
<h2 id="step-6-verify-everything-works"><a class="header" href="#step-6-verify-everything-works">Step 6: Verify Everything Works</a></h2>
<p>Test that SwissArmyHammer is working correctly:</p>
<pre><code class="language-bash"># Check if Claude Code can connect (this will show server info)
swissarmyhammer serve --help

# Run diagnostics again to see the updated status
swissarmyhammer doctor
</code></pre>
<p>The doctor command should now show that Claude Code configuration is found and prompts are loading correctly.</p>
<h2 id="whats-next"><a class="header" href="#whats-next">What‚Äôs Next?</a></h2>
<p>Now that you have SwissArmyHammer set up, you can:</p>
<ol>
<li><strong>Explore built-in prompts</strong> - See what‚Äôs available out of the box</li>
<li><strong>Create more prompts</strong> - Build your own prompt library</li>
<li><strong>Learn advanced features</strong> - Template variables, prompt organization, etc.</li>
</ol>
<h3 id="recommended-next-steps"><a class="header" href="#recommended-next-steps">Recommended Next Steps</a></h3>
<ul>
<li><a href="./first-prompt.html">Create Your First Custom Prompt</a></li>
<li><a href="./template-variables.html">Learn about Template Variables</a></li>
<li><a href="./builtin-prompts.html">Explore Built-in Prompts</a></li>
<li><a href="./advanced-prompts.html">Advanced Prompt Techniques</a></li>
</ul>
<h2 id="troubleshooting-1"><a class="header" href="#troubleshooting-1">Troubleshooting</a></h2>
<p>If something isn‚Äôt working:</p>
<ol>
<li><strong>Run the doctor</strong>: <code>swissarmyhammer doctor</code></li>
<li><strong>Check Claude Code logs</strong>: Look for any error messages</li>
<li><strong>Verify file permissions</strong>: Make sure SwissArmyHammer can read your prompt files</li>
<li><strong>Restart Claude Code</strong>: Sometimes a restart is needed after configuration changes</li>
</ol>
<p>For more detailed troubleshooting, see the <a href="./troubleshooting.html">Troubleshooting</a> guide.</p>
<h2 id="getting-help"><a class="header" href="#getting-help">Getting Help</a></h2>
<p>If you need help:</p>
<ul>
<li>Check the <a href="./troubleshooting.html">Troubleshooting</a> guide</li>
<li>Look at <a href="./examples.html">Examples</a> for inspiration</li>
<li>Ask questions in <a href="https://github.com/wballard/swissarmyhammer/discussions">GitHub Discussions</a></li>
<li>Report bugs in <a href="https://github.com/wballard/swissarmyhammer/issues">GitHub Issues</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="your-first-prompt"><a class="header" href="#your-first-prompt">Your First Prompt</a></h1>
<p>Let‚Äôs create your first custom prompt with SwissArmyHammer! This guide will walk you through creating a useful code review prompt.</p>
<h2 id="understanding-prompt-structure"><a class="header" href="#understanding-prompt-structure">Understanding Prompt Structure</a></h2>
<p>SwissArmyHammer prompts are markdown files with YAML front matter. Here‚Äôs the basic structure:</p>
<pre><code class="language-markdown">---
title: Your Prompt Title
description: What this prompt does
arguments:
  - name: argument_name
    description: What this argument is for
    required: true/false
    default: "optional default value"
---

# Your Prompt Content

Use {{argument_name}} to insert variables into your prompt.
</code></pre>
<h2 id="creating-a-code-review-prompt"><a class="header" href="#creating-a-code-review-prompt">Creating a Code Review Prompt</a></h2>
<p>Let‚Äôs create a practical code review prompt step by step.</p>
<h3 id="step-1-create-the-file"><a class="header" href="#step-1-create-the-file">Step 1: Create the File</a></h3>
<p>First, create a new prompt file in your prompts directory:</p>
<pre><code class="language-bash"># Create the file
touch ~/.swissarmyhammer/prompts/code-review.md

# Or create a category directory
mkdir -p ~/.swissarmyhammer/prompts/development
touch ~/.swissarmyhammer/prompts/development/code-review.md
</code></pre>
<h3 id="step-2-add-the-yaml-front-matter"><a class="header" href="#step-2-add-the-yaml-front-matter">Step 2: Add the YAML Front Matter</a></h3>
<p>Open the file in your favorite editor and add the front matter:</p>
<pre><code class="language-yaml">---
title: Code Review Assistant
description: Comprehensive code review with focus on best practices, security, and performance
arguments:
  - name: code
    description: The code to review (can be a function, class, or entire file)
    required: true
  - name: language
    description: Programming language (helps with language-specific advice)
    required: false
    default: "auto-detect"
  - name: focus
    description: Areas to focus on (security, performance, readability, etc.)
    required: false
    default: "general best practices"
---
</code></pre>
<h3 id="step-3-write-the-prompt-content"><a class="header" href="#step-3-write-the-prompt-content">Step 3: Write the Prompt Content</a></h3>
<p>Below the front matter, add the prompt content:</p>
<pre><code class="language-markdown"># Code Review

I need a thorough code review for the following {{language}} code.

## Code to Review

```{{language}}
{{code}}
</code></pre>
<h2 id="review-focus"><a class="header" href="#review-focus">Review Focus</a></h2>
<p>Please focus on: {{focus}}</p>
<h2 id="review-criteria"><a class="header" href="#review-criteria">Review Criteria</a></h2>
<p>Please analyze the code for:</p>
<h3 id="-security"><a class="header" href="#-security">üîí Security</a></h3>
<ul>
<li>Potential security vulnerabilities</li>
<li>Input validation issues</li>
<li>Authentication/authorization concerns</li>
</ul>
<h3 id="-performance"><a class="header" href="#-performance">üöÄ Performance</a></h3>
<ul>
<li>Inefficient algorithms or operations</li>
<li>Memory usage concerns</li>
<li>Potential bottlenecks</li>
</ul>
<h3 id="-readability--maintainability"><a class="header" href="#-readability--maintainability">üìñ Readability &amp; Maintainability</a></h3>
<ul>
<li>Code clarity and organization</li>
<li>Naming conventions</li>
<li>Documentation needs</li>
</ul>
<h3 id="-testing--reliability"><a class="header" href="#-testing--reliability">üß™ Testing &amp; Reliability</a></h3>
<ul>
<li>Error handling</li>
<li>Edge cases</li>
<li>Testability</li>
</ul>
<h3 id="-architecture--design"><a class="header" href="#-architecture--design">üèóÔ∏è Architecture &amp; Design</a></h3>
<ul>
<li>SOLID principles adherence</li>
<li>Design patterns usage</li>
<li>Code structure</li>
</ul>
<h2 id="output-format"><a class="header" href="#output-format">Output Format</a></h2>
<p>Please provide:</p>
<ol>
<li><strong>Overall Assessment</strong> - Brief summary of code quality</li>
<li><strong>Specific Issues</strong> - List each issue with:
<ul>
<li>Severity (High/Medium/Low)</li>
<li>Location (line numbers if applicable)</li>
<li>Explanation of the problem</li>
<li>Suggested fix</li>
</ul>
</li>
<li><strong>Positive Aspects</strong> - What‚Äôs done well</li>
<li><strong>Recommendations</strong> - Broader suggestions for improvement</li>
</ol>
<p>Focus especially on {{focus}} in your analysis.</p>
<pre><code>
### Step 4: Complete File Example

Here's the complete prompt file:

```markdown
---
title: Code Review Assistant
description: Comprehensive code review with focus on best practices, security, and performance
arguments:
  - name: code
    description: The code to review (can be a function, class, or entire file)
    required: true
  - name: language
    description: Programming language (helps with language-specific advice)
    required: false
    default: "auto-detect"
  - name: focus
    description: Areas to focus on (security, performance, readability, etc.)
    required: false
    default: "general best practices"
---

# Code Review

I need a thorough code review for the following {{language}} code.

## Code to Review

```{{language}}
{{code}}
</code></pre>
<h2 id="review-focus-1"><a class="header" href="#review-focus-1">Review Focus</a></h2>
<p>Please focus on: {{focus}}</p>
<h2 id="review-criteria-1"><a class="header" href="#review-criteria-1">Review Criteria</a></h2>
<p>Please analyze the code for:</p>
<h3 id="-security-1"><a class="header" href="#-security-1">üîí Security</a></h3>
<ul>
<li>Potential security vulnerabilities</li>
<li>Input validation issues</li>
<li>Authentication/authorization concerns</li>
</ul>
<h3 id="-performance-1"><a class="header" href="#-performance-1">üöÄ Performance</a></h3>
<ul>
<li>Inefficient algorithms or operations</li>
<li>Memory usage concerns</li>
<li>Potential bottlenecks</li>
</ul>
<h3 id="-readability--maintainability-1"><a class="header" href="#-readability--maintainability-1">üìñ Readability &amp; Maintainability</a></h3>
<ul>
<li>Code clarity and organization</li>
<li>Naming conventions</li>
<li>Documentation needs</li>
</ul>
<h3 id="-testing--reliability-1"><a class="header" href="#-testing--reliability-1">üß™ Testing &amp; Reliability</a></h3>
<ul>
<li>Error handling</li>
<li>Edge cases</li>
<li>Testability</li>
</ul>
<h3 id="-architecture--design-1"><a class="header" href="#-architecture--design-1">üèóÔ∏è Architecture &amp; Design</a></h3>
<ul>
<li>SOLID principles adherence</li>
<li>Design patterns usage</li>
<li>Code structure</li>
</ul>
<h2 id="output-format-1"><a class="header" href="#output-format-1">Output Format</a></h2>
<p>Please provide:</p>
<ol>
<li><strong>Overall Assessment</strong> - Brief summary of code quality</li>
<li><strong>Specific Issues</strong> - List each issue with:
<ul>
<li>Severity (High/Medium/Low)</li>
<li>Location (line numbers if applicable)</li>
<li>Explanation of the problem</li>
<li>Suggested fix</li>
</ul>
</li>
<li><strong>Positive Aspects</strong> - What‚Äôs done well</li>
<li><strong>Recommendations</strong> - Broader suggestions for improvement</li>
</ol>
<p>Focus especially on {{focus}} in your analysis.</p>
<pre><code>
## Step 5: Test Your Prompt

Save the file and test that SwissArmyHammer can load it:

```bash
# Check if your prompt loads correctly
swissarmyhammer doctor
</code></pre>
<p>The doctor command will validate your YAML syntax and confirm the prompt is loaded.</p>
<h2 id="step-6-use-your-prompt"><a class="header" href="#step-6-use-your-prompt">Step 6: Use Your Prompt</a></h2>
<ol>
<li><strong>Open Claude Code</strong></li>
<li><strong>Start a new conversation</strong></li>
<li><strong>Look for your prompt</strong> in the prompt picker - it should appear as ‚ÄúCode Review Assistant‚Äù</li>
<li><strong>Fill in the parameters</strong>:
<ul>
<li><code>code</code>: Paste some code you want reviewed</li>
<li><code>language</code>: Specify the programming language (optional)</li>
<li><code>focus</code>: Specify what to focus on (optional)</li>
</ul>
</li>
</ol>
<h2 id="understanding-what-happened"><a class="header" href="#understanding-what-happened">Understanding What Happened</a></h2>
<p>When you created this prompt, SwissArmyHammer:</p>
<ol>
<li><strong>Detected the new file</strong> using its file watcher</li>
<li><strong>Parsed the YAML front matter</strong> to understand the prompt structure</li>
<li><strong>Made it available</strong> to Claude Code via the MCP protocol</li>
<li><strong>Prepared for template substitution</strong> when the prompt is used</li>
</ol>
<h2 id="best-practices-for-your-first-prompt"><a class="header" href="#best-practices-for-your-first-prompt">Best Practices for Your First Prompt</a></h2>
<h3 id="-dos"><a class="header" href="#-dos">‚úÖ Do‚Äôs</a></h3>
<ul>
<li><strong>Use descriptive titles and descriptions</strong></li>
<li><strong>Document your arguments clearly</strong></li>
<li><strong>Provide sensible defaults</strong> for optional arguments</li>
<li><strong>Structure your prompt content</strong> with clear sections</li>
<li><strong>Use template variables</strong> to make prompts flexible</li>
</ul>
<h3 id="-donts"><a class="header" href="#-donts">‚ùå Don‚Äôts</a></h3>
<ul>
<li><strong>Don‚Äôt use required arguments unless necessary</strong></li>
<li><strong>Don‚Äôt make prompts too rigid</strong> - allow for flexibility</li>
<li><strong>Don‚Äôt forget to test</strong> your YAML syntax</li>
<li><strong>Don‚Äôt use overly complex template logic</strong> in your first prompts</li>
</ul>
<h2 id="next-steps-1"><a class="header" href="#next-steps-1">Next Steps</a></h2>
<p>Now that you‚Äôve created your first prompt, you can:</p>
<ol>
<li><strong>Create more prompts</strong> for different use cases</li>
<li><strong>Organize prompts</strong> into directories by category</li>
<li><strong>Learn advanced template features</strong> like conditionals and loops</li>
<li><strong>Share prompts</strong> with your team or the community</li>
</ol>
<h3 id="recommended-reading"><a class="header" href="#recommended-reading">Recommended Reading</a></h3>
<ul>
<li><a href="./creating-prompts.html">Creating Prompts</a> - Comprehensive guide to prompt creation</li>
<li><a href="./template-variables.html">Template Variables</a> - Advanced template features</li>
<li><a href="./prompt-organization.html">Prompt Organization</a> - How to organize your prompt library</li>
<li><a href="./builtin-prompts.html">Built-in Prompts</a> - Examples from the built-in library</li>
</ul>
<h2 id="troubleshooting-2"><a class="header" href="#troubleshooting-2">Troubleshooting</a></h2>
<p>If your prompt isn‚Äôt working:</p>
<ol>
<li><strong>Check YAML syntax</strong> - Make sure your front matter is valid YAML</li>
<li><strong>Run doctor</strong> - <code>swissarmyhammer doctor</code> will catch common issues</li>
<li><strong>Check file permissions</strong> - Make sure SwissArmyHammer can read the file</li>
<li><strong>Restart Claude Code</strong> - Sometimes needed after creating new prompts</li>
</ol>
<p>Common issues:</p>
<ul>
<li><strong>YAML indentation errors</strong> - Use spaces, not tabs</li>
<li><strong>Missing required fields</strong> - Title and description are required</li>
<li><strong>Invalid argument structure</strong> - Check the argument format</li>
<li><strong>File encoding</strong> - Use UTF-8 encoding for your markdown files</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-prompts"><a class="header" href="#creating-prompts">Creating Prompts</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="yaml-front-matter"><a class="header" href="#yaml-front-matter">YAML Front Matter</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="template-variables"><a class="header" href="#template-variables">Template Variables</a></h1>
<p>SwissArmyHammer uses the <a href="https://shopify.github.io/liquid/">Liquid template engine</a> for processing prompts. This provides powerful templating features including variables, conditionals, loops, and filters.</p>
<h2 id="basic-variable-substitution"><a class="header" href="#basic-variable-substitution">Basic Variable Substitution</a></h2>
<p>Variables are inserted using double curly braces:</p>
<pre><code class="language-liquid">Hello {{ name }}!
Your email is {{ email }}.
</code></pre>
<p>For backward compatibility, variables without spaces also work:</p>
<pre><code class="language-liquid">Hello {{name}}!
</code></pre>
<h2 id="conditionals"><a class="header" href="#conditionals">Conditionals</a></h2>
<h3 id="if-statements"><a class="header" href="#if-statements">If Statements</a></h3>
<p>Use <code>if</code> statements to conditionally include content:</p>
<pre><code class="language-liquid">{% if user_type == "admin" %}
  Welcome, administrator!
{% elsif user_type == "moderator" %}
  Welcome, moderator!
{% else %}
  Welcome, user!
{% endif %}
</code></pre>
<h3 id="unless-statements"><a class="header" href="#unless-statements">Unless Statements</a></h3>
<p><code>unless</code> is the opposite of <code>if</code>:</p>
<pre><code class="language-liquid">{% unless error_count == 0 %}
  Warning: {{ error_count }} errors found.
{% endunless %}
</code></pre>
<h3 id="comparison-operators"><a class="header" href="#comparison-operators">Comparison Operators</a></h3>
<ul>
<li><code>==</code> - equals</li>
<li><code>!=</code> - not equals</li>
<li><code>&gt;</code> - greater than</li>
<li><code>&lt;</code> - less than</li>
<li><code>&gt;=</code> - greater or equal</li>
<li><code>&lt;=</code> - less or equal</li>
<li><code>contains</code> - string/array contains</li>
<li><code>and</code> - logical AND</li>
<li><code>or</code> - logical OR</li>
</ul>
<p>Example:</p>
<pre><code class="language-liquid">{% if age &gt;= 18 and country == "US" %}
  You are eligible to vote.
{% endif %}

{% if tags contains "urgent" %}
  üö® This is urgent!
{% endif %}
</code></pre>
<h2 id="case-statements"><a class="header" href="#case-statements">Case Statements</a></h2>
<p>For multiple conditions, use <code>case</code>:</p>
<pre><code class="language-liquid">{% case status %}
  {% when "pending" %}
    ‚è≥ Waiting for approval
  {% when "approved" %}
    ‚úÖ Approved and ready
  {% when "rejected" %}
    ‚ùå Rejected
  {% else %}
    ‚ùì Unknown status
{% endcase %}
</code></pre>
<h2 id="loops"><a class="header" href="#loops">Loops</a></h2>
<h3 id="basic-for-loops"><a class="header" href="#basic-for-loops">Basic For Loops</a></h3>
<p>Iterate over arrays:</p>
<pre><code class="language-liquid">{% for item in items %}
  - {{ item }}
{% endfor %}
</code></pre>
<h3 id="range-loops"><a class="header" href="#range-loops">Range Loops</a></h3>
<p>Loop over a range of numbers:</p>
<pre><code class="language-liquid">{% for i in (1..5) %}
  Step {{ i }} of 5
{% endfor %}
</code></pre>
<h3 id="loop-variables"><a class="header" href="#loop-variables">Loop Variables</a></h3>
<p>Inside loops, you have access to special variables:</p>
<pre><code class="language-liquid">{% for item in items %}
  {% if forloop.first %}First item: {% endif %}
  {{ forloop.index }}. {{ item }}
  {% if forloop.last %}(last item){% endif %}
{% endfor %}
</code></pre>
<p>Available loop variables:</p>
<ul>
<li><code>forloop.index</code> - current iteration (1-based)</li>
<li><code>forloop.index0</code> - current iteration (0-based)</li>
<li><code>forloop.first</code> - true on first iteration</li>
<li><code>forloop.last</code> - true on last iteration</li>
<li><code>forloop.length</code> - total number of items</li>
</ul>
<h3 id="loop-control"><a class="header" href="#loop-control">Loop Control</a></h3>
<p>Use <code>break</code> and <code>continue</code> for flow control:</p>
<pre><code class="language-liquid">{% for item in items %}
  {% if item == "skip" %}
    {% continue %}
  {% endif %}
  {% if item == "stop" %}
    {% break %}
  {% endif %}
  Processing: {{ item }}
{% endfor %}
</code></pre>
<h3 id="cycle"><a class="header" href="#cycle">Cycle</a></h3>
<p>Alternate between values:</p>
<pre><code class="language-liquid">{% for row in data %}
  &lt;tr class="{% cycle 'odd', 'even' %}"&gt;
    &lt;td&gt;{{ row }}&lt;/td&gt;
  &lt;/tr&gt;
{% endfor %}
</code></pre>
<h2 id="filters"><a class="header" href="#filters">Filters</a></h2>
<p>Filters modify variables using the pipe (<code>|</code>) character:</p>
<h3 id="string-filters"><a class="header" href="#string-filters">String Filters</a></h3>
<pre><code class="language-liquid">{{ name | upcase }}           # ALICE
{{ name | downcase }}         # alice
{{ name | capitalize }}       # Alice
{{ text | strip }}            # removes whitespace
{{ text | truncate: 20 }}     # truncates to 20 chars
{{ text | truncate: 20, "..." }} # custom ellipsis
{{ text | append: "!" }}      # adds to end
{{ text | prepend: "Hello " }} # adds to beginning
{{ text | remove: "bad" }}    # removes all occurrences
{{ text | replace: "old", "new" }} # replaces all
{{ text | split: "," }}       # splits into array
</code></pre>
<h3 id="array-filters"><a class="header" href="#array-filters">Array Filters</a></h3>
<pre><code class="language-liquid">{{ array | first }}           # first element
{{ array | last }}            # last element
{{ array | join: ", " }}      # joins with delimiter
{{ array | sort }}            # sorts array
{{ array | reverse }}         # reverses array
{{ array | size }}            # number of elements
{{ array | uniq }}            # removes duplicates
</code></pre>
<h3 id="math-filters"><a class="header" href="#math-filters">Math Filters</a></h3>
<pre><code class="language-liquid">{{ number | plus: 5 }}        # addition
{{ number | minus: 3 }}       # subtraction
{{ number | times: 2 }}       # multiplication
{{ number | divided_by: 4 }}  # division
{{ number | modulo: 3 }}      # remainder
{{ number | ceil }}           # round up
{{ number | floor }}          # round down
{{ number | round }}          # round to nearest
{{ number | round: 2 }}       # round to 2 decimals
{{ number | abs }}            # absolute value
</code></pre>
<h3 id="default-filter"><a class="header" href="#default-filter">Default Filter</a></h3>
<p>Provide fallback values:</p>
<pre><code class="language-liquid">Hello {{ name | default: "Guest" }}!
Score: {{ score | default: 0 }}
</code></pre>
<h3 id="date-filters"><a class="header" href="#date-filters">Date Filters</a></h3>
<pre><code class="language-liquid">{{ date | date: "%Y-%m-%d" }}         # 2024-01-15
{{ date | date: "%B %d, %Y" }}        # January 15, 2024
{{ "now" | date: "%Y" }}              # current year
</code></pre>
<h2 id="advanced-features"><a class="header" href="#advanced-features">Advanced Features</a></h2>
<h3 id="comments"><a class="header" href="#comments">Comments</a></h3>
<p>Comments are not rendered in output:</p>
<pre><code class="language-liquid">{% comment %}
  This is a comment that won't appear in the output.
  Useful for documentation or temporarily disabling code.
{% endcomment %}
</code></pre>
<h3 id="raw-blocks"><a class="header" href="#raw-blocks">Raw Blocks</a></h3>
<p>Prevent Liquid processing:</p>
<pre><code class="language-liquid">{% raw %}
  This {{ variable }} won't be processed.
  Useful for showing Liquid syntax examples.
{% endraw %}
</code></pre>
<h3 id="assign-variables"><a class="header" href="#assign-variables">Assign Variables</a></h3>
<p>Create new variables:</p>
<pre><code class="language-liquid">{% assign full_name = first_name | append: " " | append: last_name %}
Welcome, {{ full_name }}!

{% assign item_count = items | size %}
You have {{ item_count }} items.
</code></pre>
<h3 id="capture-blocks"><a class="header" href="#capture-blocks">Capture Blocks</a></h3>
<p>Capture content into a variable:</p>
<pre><code class="language-liquid">{% capture greeting %}
  {% if time_of_day == "morning" %}
    Good morning
  {% elsif time_of_day == "evening" %}
    Good evening
  {% else %}
    Hello
  {% endif %}
{% endcapture %}

{{ greeting }}, {{ name }}!
</code></pre>
<h2 id="environment-variables"><a class="header" href="#environment-variables">Environment Variables</a></h2>
<p>Access environment variables through the <code>env</code> object:</p>
<pre><code class="language-liquid">Current user: {{ env.USER }}
Home directory: {{ env.HOME }}
Custom setting: {{ env.MY_APP_CONFIG | default: "not set" }}
</code></pre>
<h2 id="object-access"><a class="header" href="#object-access">Object Access</a></h2>
<p>Access nested objects and arrays:</p>
<pre><code class="language-liquid">{{ user.name }}
{{ user.address.city }}
{{ items[0] }}
{{ items[index] }}
{{ data["dynamic_key"] }}
</code></pre>
<h2 id="truthy-and-falsy-values"><a class="header" href="#truthy-and-falsy-values">Truthy and Falsy Values</a></h2>
<p>In Liquid conditions:</p>
<ul>
<li><strong>Falsy</strong>: <code>false</code>, <code>nil</code></li>
<li><strong>Truthy</strong>: everything else (including <code>0</code>, <code>""</code>, <code>[]</code>)</li>
</ul>
<pre><code class="language-liquid">{% if value %}
  This shows unless value is false or nil
{% endif %}
</code></pre>
<h2 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h2>
<p>When a variable is undefined:</p>
<ul>
<li>In backward-compatible mode: <code>{{ undefined }}</code> renders as <code>{{ undefined }}</code></li>
<li>With validation: An error is raised for missing required arguments</li>
</ul>
<p>Use the <code>default</code> filter to handle missing values gracefully:</p>
<pre><code class="language-liquid">{{ optional_var | default: "fallback value" }}
</code></pre>
<h2 id="migration-from-basic-templates"><a class="header" href="#migration-from-basic-templates">Migration from Basic Templates</a></h2>
<p>If you‚Äôre migrating from basic <code>{{variable}}</code> syntax:</p>
<ol>
<li><strong>Your existing templates still work</strong> - backward compatibility is maintained</li>
<li><strong>Add spaces for clarity</strong>: <code>{{var}}</code> ‚Üí <code>{{ var }}</code></li>
<li><strong>Use filters for transformation</strong>: <code>{{ name | upcase }}</code> instead of post-processing</li>
<li><strong>Add conditions for dynamic content</strong>: Use <code>{% if %}</code> blocks</li>
<li><strong>Use loops for repetitive content</strong>: Replace manual duplication with <code>{% for %}</code></li>
</ol>
<h3 id="migration-examples"><a class="header" href="#migration-examples">Migration Examples</a></h3>
<h4 id="before-basic-variable-substitution"><a class="header" href="#before-basic-variable-substitution">Before: Basic Variable Substitution</a></h4>
<pre><code>Please review the {{language}} code in {{file}}.
Focus on {{focus_area}}.
</code></pre>
<h4 id="after-enhanced-with-liquid-features"><a class="header" href="#after-enhanced-with-liquid-features">After: Enhanced with Liquid Features</a></h4>
<pre><code class="language-liquid">Please review the {{ language | capitalize }} code in {{ file }}.

{% if focus_area %}
Focus on {{ focus_area }}.
{% else %}
Perform a general code review.
{% endif %}

{% if language == "python" %}
Pay special attention to PEP 8 compliance.
{% elsif language == "javascript" %}
Check for ESLint rule violations.
{% endif %}
</code></pre>
<h4 id="before-manual-list-creation"><a class="header" href="#before-manual-list-creation">Before: Manual List Creation</a></h4>
<pre><code>Files to review:
- {{file1}}
- {{file2}}
- {{file3}}
</code></pre>
<h4 id="after-dynamic-lists-with-loops"><a class="header" href="#after-dynamic-lists-with-loops">After: Dynamic Lists with Loops</a></h4>
<pre><code class="language-liquid">Files to review:
{% for file in files %}
- {{ file }}{% if forloop.last %} (final file){% endif %}
{% endfor %}

Total: {{ files | size }} files
</code></pre>
<h4 id="before-fixed-templates"><a class="header" href="#before-fixed-templates">Before: Fixed Templates</a></h4>
<pre><code>Status: {{status}}
</code></pre>
<h4 id="after-conditional-formatting"><a class="header" href="#after-conditional-formatting">After: Conditional Formatting</a></h4>
<pre><code class="language-liquid">Status: {% case status %}
  {% when "success" %}‚úÖ {{ status | upcase }}
  {% when "error" %}‚ùå {{ status | upcase }}
  {% when "warning" %}‚ö†Ô∏è {{ status | capitalize }}
  {% else %}{{ status }}
{% endcase %}
</code></pre>
<h3 id="differences-from-handlebarsmustache"><a class="header" href="#differences-from-handlebarsmustache">Differences from Handlebars/Mustache</a></h3>
<p>If you‚Äôre familiar with Handlebars or Mustache templating:</p>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Handlebars/Mustache</th><th>Liquid</th></tr></thead><tbody>
<tr><td>Variables</td><td><code>{{variable}}</code></td><td><code>{{ variable }}</code></td></tr>
<tr><td>Conditionals</td><td><code>{{#if}}...{{/if}}</code></td><td><code>{% if %}...{% endif %}</code></td></tr>
<tr><td>Loops</td><td><code>{{#each}}...{{/each}}</code></td><td><code>{% for %}...{% endfor %}</code></td></tr>
<tr><td>Comments</td><td><code>{{! comment }}</code></td><td><code>{% comment %}...{% endcomment %}</code></td></tr>
<tr><td>Filters</td><td>Limited</td><td>Extensive built-in filters</td></tr>
<tr><td>Logic</td><td>Minimal</td><td>Full comparison operators</td></tr>
</tbody></table>
</div>
<h3 id="common-migration-patterns"><a class="header" href="#common-migration-patterns">Common Migration Patterns</a></h3>
<ol>
<li>
<p><strong>Variable with Default</strong></p>
<ul>
<li>Before: Handle missing variables in code</li>
<li>After: <code>{{ variable | default: "fallback" }}</code></li>
</ul>
</li>
<li>
<p><strong>Conditional Sections</strong></p>
<ul>
<li>Before: Generate different templates</li>
<li>After: Single template with <code>{% if %}</code> blocks</li>
</ul>
</li>
<li>
<p><strong>Repeated Content</strong></p>
<ul>
<li>Before: Manual duplication</li>
<li>After: <code>{% for %}</code> loops with <code>forloop</code> variables</li>
</ul>
</li>
<li>
<p><strong>String Transformation</strong></p>
<ul>
<li>Before: Transform in application code</li>
<li>After: Use Liquid filters directly</li>
</ul>
</li>
</ol>
<h3 id="backward-compatibility-notes"><a class="header" href="#backward-compatibility-notes">Backward Compatibility Notes</a></h3>
<ul>
<li>Simple <code>{{variable}}</code> syntax continues to work</li>
<li>Undefined variables are preserved as <code>{{ variable }}</code> in output</li>
<li>No breaking changes to existing templates</li>
<li>Gradual migration is supported - mix old and new syntax</li>
</ul>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<h3 id="dynamic-code-review"><a class="header" href="#dynamic-code-review">Dynamic Code Review</a></h3>
<pre><code class="language-liquid">{% if language == "python" %}
  Please review this Python code for PEP 8 compliance.
{% elsif language == "javascript" %}
  Please review this JavaScript code for ESLint rules.
{% else %}
  Please review this {{ language }} code for best practices.
{% endif %}

{% if include_security %}
  Also check for security vulnerabilities.
{% endif %}
</code></pre>
<h3 id="formatted-list"><a class="header" href="#formatted-list">Formatted List</a></h3>
<pre><code class="language-liquid">{% for item in tasks %}
  {{ forloop.index }}. {{ item.title }}
  {% if item.completed %}‚úì{% else %}‚óã{% endif %}
  Priority: {{ item.priority | default: "normal" }}
  {% unless item.completed %}
    Due: {{ item.due_date | date: "%B %d" }}
  {% endunless %}
{% endfor %}
</code></pre>
<h3 id="conditional-debugging"><a class="header" href="#conditional-debugging">Conditional Debugging</a></h3>
<pre><code class="language-liquid">{% if debug_mode %}
  === Debug Information ===
  Variables: {{ arguments | json }}
  Environment: {{ env.NODE_ENV | default: "development" }}
  {% for key in api_keys %}
    {{ key }}: {{ key | truncate: 8 }}...
  {% endfor %}
{% endif %}
</code></pre>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<ol>
<li><strong>Use meaningful variable names</strong>: <code>{{ user_email }}</code> instead of <code>{{ ue }}</code></li>
<li><strong>Provide defaults</strong>: <code>{{ value | default: "N/A" }}</code> for optional values</li>
<li><strong>Format output</strong>: Use filters to ensure consistent formatting</li>
<li><strong>Comment complex logic</strong>: Use <code>{% comment %}</code> blocks</li>
<li><strong>Test edge cases</strong>: Empty arrays, nil values, missing variables</li>
<li><strong>Keep it readable</strong>: Break complex templates into sections</li>
</ol>
<h2 id="custom-filters"><a class="header" href="#custom-filters">Custom Filters</a></h2>
<p>SwissArmyHammer includes specialized custom filters designed for prompt engineering:</p>
<h3 id="code-filters"><a class="header" href="#code-filters">Code Filters</a></h3>
<pre><code class="language-liquid">{{ code | format_lang: "rust" }}      # Format code with language
{{ code | extract_functions }}        # Extract function signatures
{{ path | basename }}                 # Get filename from path
{{ path | dirname }}                  # Get directory from path
{{ text | count_lines }}              # Count number of lines
{{ code | dedent }}                   # Remove common indentation
</code></pre>
<h3 id="text-processing-filters"><a class="header" href="#text-processing-filters">Text Processing Filters</a></h3>
<pre><code class="language-liquid">{{ text | extract_urls }}             # Extract URLs from text
{{ title | slugify }}                 # Convert to URL-friendly slug
{{ text | word_wrap: 80 }}            # Wrap text at 80 characters
{{ text | indent: 2 }}                # Indent all lines by 2 spaces
{{ items | bullet_list }}             # Convert array to bullet list
{{ text | highlight: "keyword" }}     # Highlight specific terms
</code></pre>
<h3 id="data-transformation-filters"><a class="header" href="#data-transformation-filters">Data Transformation Filters</a></h3>
<pre><code class="language-liquid">{{ json_string | from_json }}         # Parse JSON string
{{ data | to_json }}                  # Convert to JSON string
{{ csv_string | from_csv }}           # Parse CSV string
{{ array | to_csv }}                  # Convert to CSV string
{{ yaml_string | from_yaml }}         # Parse YAML string
{{ data | to_yaml }}                  # Convert to YAML string
</code></pre>
<h3 id="utility-filters"><a class="header" href="#utility-filters">Utility Filters</a></h3>
<pre><code class="language-liquid">{{ text | md5 }}                      # Generate MD5 hash
{{ text | sha1 }}                     # Generate SHA1 hash
{{ text | sha256 }}                   # Generate SHA256 hash
{{ number | ordinal }}                # Convert to ordinal (1st, 2nd, 3rd)
{{ 100 | lorem_words }}               # Generate lorem ipsum words
{{ date | format_date: "%Y-%m-%d" }}  # Advanced date formatting
</code></pre>
<p>For complete documentation of custom filters, see the <a href="./custom-filters.html">Custom Filters Reference</a>.</p>
<h2 id="limitations"><a class="header" href="#limitations">Limitations</a></h2>
<ol>
<li><strong>No includes</strong>: Cannot include other template files</li>
<li><strong>No custom tags</strong>: Only standard Liquid tags are supported</li>
<li><strong>Performance</strong>: Very large loops may impact performance</li>
</ol>
<h2 id="further-reading"><a class="header" href="#further-reading">Further Reading</a></h2>
<ul>
<li><a href="https://shopify.github.io/liquid/">Official Liquid Documentation</a></li>
<li><a href="https://liquidjs.com/playground.html">Liquid Playground</a> - Test templates online</li>
<li><a href="https://github.com/Shopify/liquid/wiki/Liquid-for-Designers">Liquid Cheat Sheet</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-filters-reference"><a class="header" href="#custom-filters-reference">Custom Filters Reference</a></h1>
<p>SwissArmyHammer includes a comprehensive set of custom Liquid filters designed specifically for prompt engineering and content processing.</p>
<h2 id="code-filters-1"><a class="header" href="#code-filters-1">Code Filters</a></h2>
<h3 id="format_lang"><a class="header" href="#format_lang">format_lang</a></h3>
<p>Formats code with language-specific syntax highlighting hints.</p>
<pre><code class="language-liquid">{{ code | format_lang: "rust" }}
{{ code | format_lang: language_var }}
</code></pre>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>language</code> - Programming language identifier (e.g., ‚Äúrust‚Äù, ‚Äúpython‚Äù, ‚Äújavascript‚Äù)</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-liquid">&lt;!-- Input --&gt;
{{ "fn main() { println!(\"Hello\"); }" | format_lang: "rust" }}

&lt;!-- Output --&gt;
```rust
fn main() { println!("Hello"); }
</code></pre>
<pre><code>
### extract_functions

Extracts function signatures and definitions from code.

```liquid
{{ code | extract_functions }}
{{ code | extract_functions: "detailed" }}
</code></pre>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>mode</code> (optional) - ‚Äúsignatures‚Äù (default) or ‚Äúdetailed‚Äù for full function bodies</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-liquid">&lt;!-- Input --&gt;
{{ rust_code | extract_functions }}

&lt;!-- Output --&gt;
- fn main()
- fn calculate(x: i32, y: i32) -&gt; i32
- fn process_data(data: &amp;Vec&lt;String&gt;) -&gt; Result&lt;(), Error&gt;
</code></pre>
<h3 id="basename"><a class="header" href="#basename">basename</a></h3>
<p>Extracts the filename from a file path.</p>
<pre><code class="language-liquid">{{ path | basename }}
</code></pre>
<p><strong>Example:</strong></p>
<pre><code class="language-liquid">&lt;!-- Input --&gt;
{{ "/usr/local/bin/swissarmyhammer" | basename }}

&lt;!-- Output --&gt;
swissarmyhammer
</code></pre>
<h3 id="dirname"><a class="header" href="#dirname">dirname</a></h3>
<p>Extracts the directory path from a file path.</p>
<pre><code class="language-liquid">{{ path | dirname }}
</code></pre>
<p><strong>Example:</strong></p>
<pre><code class="language-liquid">&lt;!-- Input --&gt;
{{ "/usr/local/bin/swissarmyhammer" | dirname }}

&lt;!-- Output --&gt;
/usr/local/bin
</code></pre>
<h3 id="count_lines"><a class="header" href="#count_lines">count_lines</a></h3>
<p>Counts the number of lines in text.</p>
<pre><code class="language-liquid">{{ text | count_lines }}
</code></pre>
<p><strong>Example:</strong></p>
<pre><code class="language-liquid">&lt;!-- Input --&gt;
{{ "line 1\nline 2\nline 3" | count_lines }}

&lt;!-- Output --&gt;
3
</code></pre>
<h3 id="dedent"><a class="header" href="#dedent">dedent</a></h3>
<p>Removes common leading whitespace from all lines.</p>
<pre><code class="language-liquid">{{ code | dedent }}
</code></pre>
<p><strong>Example:</strong></p>
<pre><code class="language-liquid">&lt;!-- Input --&gt;
{{ "    fn main() {\n        println!(\"Hello\");\n    }" | dedent }}

&lt;!-- Output --&gt;
fn main() {
    println!("Hello");
}
</code></pre>
<h2 id="text-processing-filters-1"><a class="header" href="#text-processing-filters-1">Text Processing Filters</a></h2>
<h3 id="extract_urls"><a class="header" href="#extract_urls">extract_urls</a></h3>
<p>Extracts all URLs from text.</p>
<pre><code class="language-liquid">{{ text | extract_urls }}
{{ text | extract_urls: "list" }}
</code></pre>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>format</code> (optional) - ‚Äúarray‚Äù (default) or ‚Äúlist‚Äù for bullet point list</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-liquid">&lt;!-- Input --&gt;
{{ "Visit https://example.com and https://github.com" | extract_urls }}

&lt;!-- Output --&gt;
["https://example.com", "https://github.com"]

&lt;!-- With list format --&gt;
{{ "Visit https://example.com and https://github.com" | extract_urls: "list" }}

&lt;!-- Output --&gt;
- https://example.com
- https://github.com
</code></pre>
<h3 id="slugify"><a class="header" href="#slugify">slugify</a></h3>
<p>Converts text to a URL-friendly slug.</p>
<pre><code class="language-liquid">{{ title | slugify }}
</code></pre>
<p><strong>Example:</strong></p>
<pre><code class="language-liquid">&lt;!-- Input --&gt;
{{ "Advanced Code Review Helper!" | slugify }}

&lt;!-- Output --&gt;
advanced-code-review-helper
</code></pre>
<h3 id="word_wrap"><a class="header" href="#word_wrap">word_wrap</a></h3>
<p>Wraps text at specified column width.</p>
<pre><code class="language-liquid">{{ text | word_wrap: 80 }}
{{ text | word_wrap: width_var }}
</code></pre>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>width</code> - Column width for wrapping (default: 80)</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-liquid">&lt;!-- Input --&gt;
{{ "This is a very long line that should be wrapped at a specific column width to ensure readability." | word_wrap: 30 }}

&lt;!-- Output --&gt;
This is a very long line that
should be wrapped at a specific
column width to ensure
readability.
</code></pre>
<h3 id="indent"><a class="header" href="#indent">indent</a></h3>
<p>Indents all lines by specified number of spaces.</p>
<pre><code class="language-liquid">{{ text | indent: 4 }}
{{ text | indent: spaces_var }}
</code></pre>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>spaces</code> - Number of spaces to indent (default: 2)</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-liquid">&lt;!-- Input --&gt;
{{ "line 1\nline 2" | indent: 4 }}

&lt;!-- Output --&gt;
    line 1
    line 2
</code></pre>
<h3 id="bullet_list"><a class="header" href="#bullet_list">bullet_list</a></h3>
<p>Converts an array to a bullet point list.</p>
<pre><code class="language-liquid">{{ array | bullet_list }}
{{ array | bullet_list: "*" }}
</code></pre>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>bullet</code> (optional) - Bullet character (default: ‚Äú-‚Äù)</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-liquid">&lt;!-- Input --&gt;
{{ ["Item 1", "Item 2", "Item 3"] | bullet_list }}

&lt;!-- Output --&gt;
- Item 1
- Item 2
- Item 3

&lt;!-- With custom bullet --&gt;
{{ ["Item 1", "Item 2"] | bullet_list: "*" }}

&lt;!-- Output --&gt;
* Item 1
* Item 2
</code></pre>
<h3 id="highlight"><a class="header" href="#highlight">highlight</a></h3>
<p>Highlights specific terms in text.</p>
<pre><code class="language-liquid">{{ text | highlight: "keyword" }}
{{ text | highlight: term_var }}
</code></pre>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>term</code> - Term to highlight</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-liquid">&lt;!-- Input --&gt;
{{ "This is important text with keywords" | highlight: "important" }}

&lt;!-- Output --&gt;
This is **important** text with keywords
</code></pre>
<h2 id="data-transformation-filters-1"><a class="header" href="#data-transformation-filters-1">Data Transformation Filters</a></h2>
<h3 id="from_json"><a class="header" href="#from_json">from_json</a></h3>
<p>Parses JSON string into object/array.</p>
<pre><code class="language-liquid">{{ json_string | from_json }}
</code></pre>
<p><strong>Example:</strong></p>
<pre><code class="language-liquid">&lt;!-- Input --&gt;
{% assign data = '{"name": "John", "age": 30}' | from_json %}
Name: {{ data.name }}
Age: {{ data.age }}

&lt;!-- Output --&gt;
Name: John
Age: 30
</code></pre>
<h3 id="to_json"><a class="header" href="#to_json">to_json</a></h3>
<p>Converts object/array to JSON string.</p>
<pre><code class="language-liquid">{{ data | to_json }}
{{ data | to_json: "pretty" }}
</code></pre>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>format</code> (optional) - ‚Äúcompact‚Äù (default) or ‚Äúpretty‚Äù for formatted output</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-liquid">&lt;!-- Input --&gt;
{% assign user = { "name": "John", "age": 30 } %}
{{ user | to_json: "pretty" }}

&lt;!-- Output --&gt;
{
  "name": "John",
  "age": 30
}
</code></pre>
<h3 id="from_csv"><a class="header" href="#from_csv">from_csv</a></h3>
<p>Parses CSV string into array of objects.</p>
<pre><code class="language-liquid">{{ csv_string | from_csv }}
{{ csv_string | from_csv: ";" }}
</code></pre>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>delimiter</code> (optional) - Field delimiter (default: ‚Äú,‚Äù)</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-liquid">&lt;!-- Input --&gt;
{% assign data = "name,age\nJohn,30\nJane,25" | from_csv %}
{% for row in data %}
- {{ row.name }} is {{ row.age }} years old
{% endfor %}

&lt;!-- Output --&gt;
- John is 30 years old
- Jane is 25 years old
</code></pre>
<h3 id="to_csv"><a class="header" href="#to_csv">to_csv</a></h3>
<p>Converts array of objects to CSV string.</p>
<pre><code class="language-liquid">{{ array | to_csv }}
{{ array | to_csv: ";" }}
</code></pre>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>delimiter</code> (optional) - Field delimiter (default: ‚Äú,‚Äù)</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-liquid">&lt;!-- Input --&gt;
{% assign users = [{"name": "John", "age": 30}, {"name": "Jane", "age": 25}] %}
{{ users | to_csv }}

&lt;!-- Output --&gt;
name,age
John,30
Jane,25
</code></pre>
<h3 id="from_yaml"><a class="header" href="#from_yaml">from_yaml</a></h3>
<p>Parses YAML string into object/array.</p>
<pre><code class="language-liquid">{{ yaml_string | from_yaml }}
</code></pre>
<p><strong>Example:</strong></p>
<pre><code class="language-liquid">&lt;!-- Input --&gt;
{% assign config = "database:\n  host: localhost\n  port: 5432" | from_yaml %}
Host: {{ config.database.host }}
Port: {{ config.database.port }}

&lt;!-- Output --&gt;
Host: localhost
Port: 5432
</code></pre>
<h3 id="to_yaml"><a class="header" href="#to_yaml">to_yaml</a></h3>
<p>Converts object/array to YAML string.</p>
<pre><code class="language-liquid">{{ data | to_yaml }}
</code></pre>
<p><strong>Example:</strong></p>
<pre><code class="language-liquid">&lt;!-- Input --&gt;
{% assign config = {"database": {"host": "localhost", "port": 5432}} %}
{{ config | to_yaml }}

&lt;!-- Output --&gt;
database:
  host: localhost
  port: 5432
</code></pre>
<h2 id="hash-filters"><a class="header" href="#hash-filters">Hash Filters</a></h2>
<h3 id="md5"><a class="header" href="#md5">md5</a></h3>
<p>Generates MD5 hash of input text.</p>
<pre><code class="language-liquid">{{ text | md5 }}
</code></pre>
<p><strong>Example:</strong></p>
<pre><code class="language-liquid">&lt;!-- Input --&gt;
{{ "hello world" | md5 }}

&lt;!-- Output --&gt;
5d41402abc4b2a76b9719d911017c592
</code></pre>
<h3 id="sha1"><a class="header" href="#sha1">sha1</a></h3>
<p>Generates SHA1 hash of input text.</p>
<pre><code class="language-liquid">{{ text | sha1 }}
</code></pre>
<p><strong>Example:</strong></p>
<pre><code class="language-liquid">&lt;!-- Input --&gt;
{{ "hello world" | sha1 }}

&lt;!-- Output --&gt;
2aae6c35c94fcfb415dbe95f408b9ce91ee846ed
</code></pre>
<h3 id="sha256"><a class="header" href="#sha256">sha256</a></h3>
<p>Generates SHA256 hash of input text.</p>
<pre><code class="language-liquid">{{ text | sha256 }}
</code></pre>
<p><strong>Example:</strong></p>
<pre><code class="language-liquid">&lt;!-- Input --&gt;
{{ "hello world" | sha256 }}

&lt;!-- Output --&gt;
b94d27b9934d3e08a52e52d7da7dabfac484efe37a5380ee9088f7ace2efcde9
</code></pre>
<h2 id="utility-filters-1"><a class="header" href="#utility-filters-1">Utility Filters</a></h2>
<h3 id="ordinal"><a class="header" href="#ordinal">ordinal</a></h3>
<p>Converts number to ordinal format (1st, 2nd, 3rd, etc.).</p>
<pre><code class="language-liquid">{{ number | ordinal }}
</code></pre>
<p><strong>Example:</strong></p>
<pre><code class="language-liquid">&lt;!-- Input --&gt;
{{ 1 | ordinal }} item
{{ 22 | ordinal }} place
{{ 103 | ordinal }} attempt

&lt;!-- Output --&gt;
1st item
22nd place
103rd attempt
</code></pre>
<h3 id="lorem_words"><a class="header" href="#lorem_words">lorem_words</a></h3>
<p>Generates lorem ipsum text with specified number of words.</p>
<pre><code class="language-liquid">{{ count | lorem_words }}
</code></pre>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>count</code> - Number of words to generate</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-liquid">&lt;!-- Input --&gt;
{{ 10 | lorem_words }}

&lt;!-- Output --&gt;
Lorem ipsum dolor sit amet consectetur adipiscing elit sed do eiusmod
</code></pre>
<h3 id="format_date"><a class="header" href="#format_date">format_date</a></h3>
<p>Advanced date formatting with custom format strings.</p>
<pre><code class="language-liquid">{{ date | format_date: "%Y-%m-%d %H:%M:%S" }}
{{ "now" | format_date: "%B %d, %Y" }}
</code></pre>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>format</code> - Date format string (uses strftime format)</li>
</ul>
<p><strong>Common format codes:</strong></p>
<ul>
<li><code>%Y</code> - 4-digit year (2024)</li>
<li><code>%m</code> - Month as number (01-12)</li>
<li><code>%d</code> - Day of month (01-31)</li>
<li><code>%H</code> - Hour (00-23)</li>
<li><code>%M</code> - Minute (00-59)</li>
<li><code>%S</code> - Second (00-59)</li>
<li><code>%B</code> - Full month name (January)</li>
<li><code>%b</code> - Abbreviated month (Jan)</li>
<li><code>%A</code> - Full weekday name (Monday)</li>
<li><code>%a</code> - Abbreviated weekday (Mon)</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-liquid">&lt;!-- Input --&gt;
{{ "2024-01-15T10:30:00Z" | format_date: "%B %d, %Y at %I:%M %p" }}
{{ "now" | format_date: "%A, %Y-%m-%d" }}

&lt;!-- Output --&gt;
January 15, 2024 at 10:30 AM
Monday, 2024-01-15
</code></pre>
<h2 id="filter-chaining"><a class="header" href="#filter-chaining">Filter Chaining</a></h2>
<p>Filters can be chained together for complex transformations:</p>
<pre><code class="language-liquid">{{ code | dedent | format_lang: "python" | highlight: "def" }}

{{ user_input | strip | truncate: 100 | capitalize }}

{{ data | to_json | indent: 2 }}

{{ filename | basename | slugify | append: ".md" }}
</code></pre>
<h2 id="error-handling-1"><a class="header" href="#error-handling-1">Error Handling</a></h2>
<p>Custom filters handle errors gracefully:</p>
<ul>
<li><strong>Invalid input</strong>: Returns original value or empty string</li>
<li><strong>Missing arguments</strong>: Uses sensible defaults</li>
<li><strong>Type mismatches</strong>: Attempts conversion or returns original value</li>
</ul>
<h2 id="performance-notes"><a class="header" href="#performance-notes">Performance Notes</a></h2>
<ul>
<li><strong>Hash filters</strong> (md5, sha1, sha256) are computationally expensive for large inputs</li>
<li><strong>Data transformation filters</strong> (JSON, CSV, YAML) may consume memory for large datasets</li>
<li><strong>Text processing filters</strong> are optimized for typical prompt content sizes</li>
<li><strong>Code filters</strong> use efficient parsing algorithms</li>
</ul>
<h2 id="integration-examples"><a class="header" href="#integration-examples">Integration Examples</a></h2>
<h3 id="code-review-prompt"><a class="header" href="#code-review-prompt">Code Review Prompt</a></h3>
<pre><code class="language-liquid"># Code Review: {{ filename | basename }}

## File Information
- **Path**: {{ filepath }}
- **Lines**: {{ code | count_lines }}
- **Language**: {{ language | capitalize }}

## Code to Review
{{ code | dedent | format_lang: language }}

## Functions Found
{{ code | extract_functions | bullet_list }}

## Review Checklist
{% assign hash = code | sha256 | truncate: 8 %}
- [ ] Security review (ID: {{ hash }})
- [ ] Performance analysis
- [ ] Style compliance
</code></pre>
<h3 id="data-analysis-prompt"><a class="header" href="#data-analysis-prompt">Data Analysis Prompt</a></h3>
<pre><code class="language-liquid"># Data Analysis Report

## Dataset Summary
{% assign data = csv_data | from_csv %}
- **Records**: {{ data | size }}
- **Generated**: {{ "now" | format_date: "%Y-%m-%d %H:%M" }}

## Sample Data
{% for row in data limit:3 %}
{{ forloop.index | ordinal }} record: {{ row | to_json }}
{% endfor %}

## Field Analysis
{% assign fields = data[0] | keys %}
Available fields: {{ fields | bullet_list }}
</code></pre>
<h3 id="documentation-generator"><a class="header" href="#documentation-generator">Documentation Generator</a></h3>
<pre><code class="language-liquid"># API Documentation

## Endpoints
{% for endpoint in api_endpoints %}
### {{ endpoint.method | upcase }} {{ endpoint.path }}

{{ endpoint.description | word_wrap: 80 }}

{% if endpoint.parameters %}
**Parameters:**
{{ endpoint.parameters | to_yaml | indent: 2 }}
{% endif %}

**Example:**
```{{ endpoint.language | default: "bash" }}
{{ endpoint.example | dedent }}
</code></pre>
<p>{% endfor %}</p>
<hr />
<p><em>Generated on {{ ‚Äúnow‚Äù | format_date: ‚Äú%B %d, %Y‚Äù }}</em></p>
<pre><code>
## See Also

- [Template Variables](./template-variables.md) - Basic Liquid syntax
- [Advanced Prompts](./advanced-prompts.md) - Using filters in complex templates
- [Testing Guide](./testing-guide.md) - Testing templates with custom filters</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prompt-organization"><a class="header" href="#prompt-organization">Prompt Organization</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-with-claude-code"><a class="header" href="#using-with-claude-code">Using with Claude Code</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="command-line-interface"><a class="header" href="#command-line-interface">Command Line Interface</a></h1>
<p>SwissArmyHammer provides a comprehensive command-line interface for managing prompts, running the MCP server, and integrating with your development workflow.</p>
<h2 id="installation-1"><a class="header" href="#installation-1">Installation</a></h2>
<pre><code class="language-bash"># Install from Git repository (requires Rust)
cargo install --git https://github.com/wballard/swissarmyhammer.git swissarmyhammer-cli

# Ensure ~/.cargo/bin is in your PATH
export PATH="$HOME/.cargo/bin:$PATH"
</code></pre>
<h2 id="basic-usage"><a class="header" href="#basic-usage">Basic Usage</a></h2>
<pre><code class="language-bash">swissarmyhammer [COMMAND] [OPTIONS]
</code></pre>
<h2 id="global-options"><a class="header" href="#global-options">Global Options</a></h2>
<ul>
<li><code>--help, -h</code> - Display help information</li>
<li><code>--version, -V</code> - Display version information</li>
</ul>
<h2 id="commands-overview"><a class="header" href="#commands-overview">Commands Overview</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody>
<tr><td><a href="./cli-serve.html"><code>serve</code></a></td><td>Run as MCP server for Claude Code integration</td></tr>
<tr><td><a href="./cli-search.html"><code>search</code></a></td><td>Search and discover prompts with powerful filtering</td></tr>
<tr><td><a href="./cli-test.html"><code>test</code></a></td><td>Interactively test prompts with arguments</td></tr>
<tr><td><a href="./cli-export.html"><code>export</code></a></td><td>Export prompts for sharing and backup</td></tr>
<tr><td><a href="./cli-import.html"><code>import</code></a></td><td>Import prompts from various sources</td></tr>
<tr><td><a href="./cli-doctor.html"><code>doctor</code></a></td><td>Diagnose configuration and setup issues</td></tr>
<tr><td><a href="./cli-completion.html"><code>completion</code></a></td><td>Generate shell completion scripts</td></tr>
</tbody></table>
</div>
<h2 id="quick-examples"><a class="header" href="#quick-examples">Quick Examples</a></h2>
<h3 id="start-mcp-server"><a class="header" href="#start-mcp-server">Start MCP Server</a></h3>
<pre><code class="language-bash"># Run as MCP server (for Claude Code)
swissarmyhammer serve
</code></pre>
<h3 id="search-for-prompts"><a class="header" href="#search-for-prompts">Search for Prompts</a></h3>
<pre><code class="language-bash"># Search for code-related prompts
swissarmyhammer search code

# Search with regex in descriptions
swissarmyhammer search --regex "test.*unit" --in description
</code></pre>
<h3 id="test-a-prompt"><a class="header" href="#test-a-prompt">Test a Prompt</a></h3>
<pre><code class="language-bash"># Interactively test a prompt
swissarmyhammer test code-review

# Test with predefined arguments
swissarmyhammer test code-review --arg code="fn main() { println!(\"Hello\"); }"
</code></pre>
<h3 id="export-and-import-prompts"><a class="header" href="#export-and-import-prompts">Export and Import Prompts</a></h3>
<pre><code class="language-bash"># Export all prompts to a tar.gz file
swissarmyhammer export --all --format tar.gz my-prompts.tar.gz

# Import prompts from URL
swissarmyhammer import https://example.com/prompts.tar.gz
</code></pre>
<h3 id="check-setup"><a class="header" href="#check-setup">Check Setup</a></h3>
<pre><code class="language-bash"># Diagnose any configuration issues
swissarmyhammer doctor
</code></pre>
<h3 id="generate-shell-completions"><a class="header" href="#generate-shell-completions">Generate Shell Completions</a></h3>
<pre><code class="language-bash"># Generate Bash completions
swissarmyhammer completion bash &gt; ~/.bash_completion.d/swissarmyhammer

# Generate Zsh completions
swissarmyhammer completion zsh &gt; ~/.zfunc/_swissarmyhammer
</code></pre>
<h2 id="exit-codes"><a class="header" href="#exit-codes">Exit Codes</a></h2>
<ul>
<li><code>0</code> - Success</li>
<li><code>1</code> - General error</li>
<li><code>2</code> - Command line usage error</li>
<li><code>3</code> - Configuration error</li>
<li><code>4</code> - Prompt not found</li>
<li><code>5</code> - Template rendering error</li>
</ul>
<h2 id="configuration"><a class="header" href="#configuration">Configuration</a></h2>
<p>SwissArmyHammer looks for prompts in these directories (in order):</p>
<ol>
<li>Built-in prompts (embedded in the binary)</li>
<li>User prompts: <code>~/.swissarmyhammer/prompts/</code></li>
<li>Local prompts: <code>./prompts/</code> (current directory)</li>
</ol>
<p>For detailed command documentation, see the individual command pages linked in the table above.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="serve"><a class="header" href="#serve">serve</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="search---search-and-discover-prompts"><a class="header" href="#search---search-and-discover-prompts">search - Search and Discover Prompts</a></h1>
<p>The <code>search</code> command provides powerful functionality to find prompts in your collection using various search strategies and filters.</p>
<h2 id="synopsis"><a class="header" href="#synopsis">Synopsis</a></h2>
<pre><code class="language-bash">swissarmyhammer search [OPTIONS] [QUERY]
</code></pre>
<h2 id="description"><a class="header" href="#description">Description</a></h2>
<p>Search through your prompt collection using fuzzy matching, regular expressions, or exact text matching. The search can target specific fields and provides relevance-ranked results.</p>
<h2 id="arguments"><a class="header" href="#arguments">Arguments</a></h2>
<ul>
<li><code>QUERY</code> - Search term or pattern (optional if using filters)</li>
</ul>
<h2 id="options"><a class="header" href="#options">Options</a></h2>
<h3 id="search-strategy"><a class="header" href="#search-strategy">Search Strategy</a></h3>
<ul>
<li><code>--case-sensitive, -c</code> - Enable case-sensitive matching</li>
<li><code>--regex, -r</code> - Use regular expressions instead of fuzzy matching</li>
<li><code>--full, -f</code> - Show full prompt content in results</li>
</ul>
<h3 id="field-targeting"><a class="header" href="#field-targeting">Field Targeting</a></h3>
<ul>
<li><code>--in FIELD</code> - Search in specific field (title, description, content, all)
<ul>
<li><code>title</code> - Search only in prompt titles</li>
<li><code>description</code> - Search only in prompt descriptions</li>
<li><code>content</code> - Search only in prompt content/body</li>
<li><code>all</code> - Search in all fields (default)</li>
</ul>
</li>
</ul>
<h3 id="filtering"><a class="header" href="#filtering">Filtering</a></h3>
<ul>
<li><code>--source SOURCE</code> - Filter by prompt source (builtin, user, local)</li>
<li><code>--has-arg ARG</code> - Show prompts that have a specific argument</li>
<li><code>--no-args</code> - Show prompts with no arguments</li>
</ul>
<h3 id="output-control"><a class="header" href="#output-control">Output Control</a></h3>
<ul>
<li><code>--limit, -l N</code> - Limit results to N prompts (default: 20)</li>
<li><code>--json</code> - Output results in JSON format</li>
</ul>
<h2 id="examples-1"><a class="header" href="#examples-1">Examples</a></h2>
<h3 id="basic-search"><a class="header" href="#basic-search">Basic Search</a></h3>
<pre><code class="language-bash"># Find prompts containing "code"
swissarmyhammer search code

# Case-sensitive search
swissarmyhammer search --case-sensitive "Code Review"
</code></pre>
<h3 id="field-specific-search"><a class="header" href="#field-specific-search">Field-Specific Search</a></h3>
<pre><code class="language-bash"># Search only in titles
swissarmyhammer search --in title "review"

# Search only in descriptions
swissarmyhammer search --in description "debugging"

# Search in content/body
swissarmyhammer search --in content "TODO"
</code></pre>
<h3 id="regular-expression-search"><a class="header" href="#regular-expression-search">Regular Expression Search</a></h3>
<pre><code class="language-bash"># Find prompts with "test" followed by any word
swissarmyhammer search --regex "test\s+\w+"

# Find prompts starting with specific pattern
swissarmyhammer search --regex "^(debug|fix|analyze)"
</code></pre>
<h3 id="advanced-filtering"><a class="header" href="#advanced-filtering">Advanced Filtering</a></h3>
<pre><code class="language-bash"># Find built-in prompts only
swissarmyhammer search --source builtin

# Find prompts with "code" argument
swissarmyhammer search --has-arg code

# Find prompts without any arguments
swissarmyhammer search --no-args

# Combine filters
swissarmyhammer search review --source user --has-arg language
</code></pre>
<h3 id="output-options"><a class="header" href="#output-options">Output Options</a></h3>
<pre><code class="language-bash"># Show full content of matching prompts
swissarmyhammer search code --full

# Limit to 5 results
swissarmyhammer search --limit 5 test

# Get JSON output for scripting
swissarmyhammer search --json "data analysis"
</code></pre>
<h2 id="output-format-2"><a class="header" href="#output-format-2">Output Format</a></h2>
<h3 id="default-output"><a class="header" href="#default-output">Default Output</a></h3>
<pre><code>Found 3 prompts matching "code":

üìù code-review (builtin)
   Review code for best practices and potential issues
   Arguments: code, language (optional)

üîß debug-code (user)
   Help debug programming issues and errors
   Arguments: error, context (optional)

üìä analyze-performance (local)
   Analyze code performance and suggest optimizations
   Arguments: code, language, metrics (optional)
</code></pre>
<h3 id="json-output"><a class="header" href="#json-output">JSON Output</a></h3>
<pre><code class="language-json">{
  "query": "code",
  "results": [
    {
      "id": "code-review",
      "title": "Code Review Helper",
      "description": "Review code for best practices and potential issues",
      "source": "builtin",
      "path": "/builtin/review/code.md",
      "arguments": [
        {"name": "code", "required": true},
        {"name": "language", "required": false, "default": "auto-detect"}
      ],
      "score": 0.95
    }
  ],
  "total_found": 3
}
</code></pre>
<h2 id="search-scoring"><a class="header" href="#search-scoring">Search Scoring</a></h2>
<p>Results are ranked by relevance using these factors:</p>
<ol>
<li><strong>Exact matches</strong> score higher than partial matches</li>
<li><strong>Title matches</strong> score higher than description or content matches</li>
<li><strong>Multiple field matches</strong> increase the overall score</li>
<li><strong>Argument name matches</strong> are considered for relevance</li>
</ol>
<h2 id="performance"><a class="header" href="#performance">Performance</a></h2>
<ul>
<li>Search is optimized with an in-memory index</li>
<li>Fuzzy matching uses efficient algorithms</li>
<li>Results are cached for repeated queries</li>
<li>Large prompt collections are handled efficiently</li>
</ul>
<h2 id="integration-with-other-commands"><a class="header" href="#integration-with-other-commands">Integration with Other Commands</a></h2>
<p>Search integrates well with other SwissArmyHammer commands:</p>
<pre><code class="language-bash"># Find and test a prompt
PROMPT=$(swissarmyhammer search --json code | jq -r '.results[0].id')
swissarmyhammer test "$PROMPT"

# Export search results
swissarmyhammer search debug --limit 5 | \
  grep -o '\w\+-\w\+' | \
  xargs swissarmyhammer export
</code></pre>
<h2 id="see-also"><a class="header" href="#see-also">See Also</a></h2>
<ul>
<li><a href="./cli-test.html"><code>test</code></a> - Test prompts found through search</li>
<li><a href="./cli-export.html"><code>export</code></a> - Export specific prompts</li>
<li><a href="./search-guide.html">Search Guide</a> - Advanced search strategies</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="test---interactive-prompt-testing"><a class="header" href="#test---interactive-prompt-testing">test - Interactive Prompt Testing</a></h1>
<p>The <code>test</code> command allows you to test prompts interactively, providing argument values and seeing the rendered output before using them with AI models.</p>
<h2 id="synopsis-1"><a class="header" href="#synopsis-1">Synopsis</a></h2>
<pre><code class="language-bash">swissarmyhammer test [OPTIONS] &lt;PROMPT_ID&gt;
</code></pre>
<h2 id="description-1"><a class="header" href="#description-1">Description</a></h2>
<p>Test prompts interactively by providing arguments and viewing the rendered output. This is essential for debugging template issues, validating arguments, and refining prompts before deployment.</p>
<h2 id="arguments-1"><a class="header" href="#arguments-1">Arguments</a></h2>
<ul>
<li><code>PROMPT_ID</code> - The ID of the prompt to test (required)</li>
</ul>
<h2 id="options-1"><a class="header" href="#options-1">Options</a></h2>
<h3 id="argument-specification"><a class="header" href="#argument-specification">Argument Specification</a></h3>
<ul>
<li><code>--arg KEY=VALUE</code> - Provide argument values directly (can be used multiple times)</li>
</ul>
<h3 id="output-control-1"><a class="header" href="#output-control-1">Output Control</a></h3>
<ul>
<li><code>--raw</code> - Show raw template without rendering</li>
<li><code>--copy</code> - Copy rendered result to clipboard</li>
<li><code>--save FILE</code> - Save rendered result to file</li>
<li><code>--debug</code> - Show detailed debug information including variable resolution</li>
</ul>
<h2 id="interactive-mode"><a class="header" href="#interactive-mode">Interactive Mode</a></h2>
<p>When no <code>--arg</code> options are provided, the command enters interactive mode:</p>
<ol>
<li><strong>Prompt Selection</strong>: If prompt ID is ambiguous, presents a fuzzy selector</li>
<li><strong>Argument Collection</strong>: Prompts for each required and optional argument</li>
<li><strong>Template Rendering</strong>: Shows the rendered output</li>
<li><strong>Actions</strong>: Offers to copy to clipboard or save to file</li>
</ol>
<h2 id="examples-2"><a class="header" href="#examples-2">Examples</a></h2>
<h3 id="interactive-testing"><a class="header" href="#interactive-testing">Interactive Testing</a></h3>
<pre><code class="language-bash"># Test a prompt interactively
swissarmyhammer test code-review

# The command will prompt for arguments:
# ? Enter value for 'code' (required): fn main() { println!("Hello"); }
# ? Enter value for 'language' (optional, default: auto-detect): rust
# 
# [Rendered output shows here]
# 
# ? What would you like to do?
#   &gt; View output
#     Copy to clipboard
#     Save to file
#     Test with different arguments
#     Exit
</code></pre>
<h3 id="non-interactive-testing"><a class="header" href="#non-interactive-testing">Non-Interactive Testing</a></h3>
<pre><code class="language-bash"># Test with predefined arguments
swissarmyhammer test code-review \
  --arg code="fn main() { println!(\"Hello\"); }" \
  --arg language="rust"

# Test and copy to clipboard
swissarmyhammer test debug-helper \
  --arg error="compiler error" \
  --copy

# Test and save output
swissarmyhammer test api-docs \
  --arg code="$(cat src/api.rs)" \
  --save generated-docs.md
</code></pre>
<h3 id="debug-mode"><a class="header" href="#debug-mode">Debug Mode</a></h3>
<pre><code class="language-bash"># Show debug information
swissarmyhammer test template-complex --debug

# Output includes:
# Variables resolved:
#   user_input: "example text"
#   timestamp: "2024-01-15T10:30:00Z"
#   
# Template processing:
#   Line 5: Variable 'user_input' resolved to "example text"
#   Line 12: Filter 'capitalize' applied
#   Line 18: Conditional block evaluated to true
#
# Final output:
# [rendered template]
</code></pre>
<h3 id="raw-template-view"><a class="header" href="#raw-template-view">Raw Template View</a></h3>
<pre><code class="language-bash"># View the raw template without rendering
swissarmyhammer test email-template --raw

# Shows:
# ---
# title: Email Template
# arguments:
#   - name: recipient
#     required: true
# ---
# 
# Dear {{recipient | capitalize}},
# 
# {% if urgent %}
# **URGENT:** 
# {% endif %}
# {{message}}
</code></pre>
<h2 id="output-format-3"><a class="header" href="#output-format-3">Output Format</a></h2>
<h3 id="default-output-1"><a class="header" href="#default-output-1">Default Output</a></h3>
<pre><code>Testing prompt: code-review

Arguments:
  code: "fn main() { println!(\"Hello\"); }"
  language: "rust" (default: auto-detect)

Rendered Output:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ # Code Review                                               ‚îÇ
‚îÇ                                                             ‚îÇ
‚îÇ Please review the following rust code:                     ‚îÇ
‚îÇ                                                             ‚îÇ
‚îÇ ```rust                                                     ‚îÇ
‚îÇ fn main() { println!("Hello"); }                           ‚îÇ
‚îÇ ```                                                         ‚îÇ
‚îÇ                                                             ‚îÇ
‚îÇ Focus on:                                                   ‚îÇ
‚îÇ - Code quality and readability                             ‚îÇ
‚îÇ - Potential bugs or security issues                        ‚îÇ
‚îÇ - Performance considerations                                ‚îÇ
‚îÇ - Best practices adherence                                  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

‚úì Template rendered successfully (247 characters)
</code></pre>
<h3 id="debug-output"><a class="header" href="#debug-output">Debug Output</a></h3>
<pre><code>Testing prompt: code-review (debug mode)

Prompt loaded from: ~/.swissarmyhammer/prompts/review/code.md
Arguments defined: 2 (1 required, 1 optional)

Argument Resolution:
‚úì code: "fn main() { println!(\"Hello\"); }" [user provided]
‚úì language: "rust" [user provided, overrides default "auto-detect"]

Template Processing:
‚Üí Line 8: Variable 'language' resolved and capitalized
‚Üí Line 12-14: Code block with 'code' variable substitution
‚Üí Line 16-20: Static bullet list rendered

Filters Applied:
- capitalize: "rust" ‚Üí "Rust"

Rendered Output:
[... same as above ...]

Performance:
- Template parsing: 2ms
- Variable resolution: 1ms
- Rendering: 3ms
- Total: 6ms
</code></pre>
<h2 id="error-handling-2"><a class="header" href="#error-handling-2">Error Handling</a></h2>
<p>The test command provides helpful error messages for common issues:</p>
<h3 id="missing-arguments"><a class="header" href="#missing-arguments">Missing Arguments</a></h3>
<pre><code class="language-bash">$ swissarmyhammer test code-review
Error: Missing required argument 'code'

Available arguments:
  code (required) - The code to review
  language (optional) - Programming language (default: auto-detect)

Use --arg KEY=VALUE to provide arguments, or run without --arg for interactive mode.
</code></pre>
<h3 id="template-errors"><a class="header" href="#template-errors">Template Errors</a></h3>
<pre><code class="language-bash">$ swissarmyhammer test broken-template --arg data="test"
Error: Template rendering failed at line 15

  13 | {% for item in items %}
  14 |   - {{item.name}}
&gt; 15 |   - {{item.invalid_field | unknown_filter}}
     |                           ^^^^^^^^^^^^^^
  16 | {% endfor %}

Unknown filter: unknown_filter
Available filters: capitalize, lower, upper, truncate, ...

Fix the template and try again.
</code></pre>
<h2 id="integration-with-development-workflow"><a class="header" href="#integration-with-development-workflow">Integration with Development Workflow</a></h2>
<h3 id="testing-before-deployment"><a class="header" href="#testing-before-deployment">Testing Before Deployment</a></h3>
<pre><code class="language-bash"># Test a prompt before adding to Claude Code
swissarmyhammer test new-prompt --debug

# Validate all prompts in a directory
for prompt in $(ls prompts/*.md); do
  swissarmyhammer test "${prompt%.md}" --arg placeholder="test"
done
</code></pre>
<h3 id="clipboard-integration"><a class="header" href="#clipboard-integration">Clipboard Integration</a></h3>
<pre><code class="language-bash"># Test and copy for immediate use
swissarmyhammer test quick-note \
  --arg content="Meeting notes" \
  --copy

# Now paste into your editor or Claude Code
</code></pre>
<h3 id="script-integration"><a class="header" href="#script-integration">Script Integration</a></h3>
<pre><code class="language-bash">#!/bin/bash
# test-and-deploy.sh

PROMPT_ID="$1"
if swissarmyhammer test "$PROMPT_ID" --arg test="validation"; then
  echo "‚úì Prompt test passed, deploying..."
  swissarmyhammer export "$PROMPT_ID" --format directory deployment/
else
  echo "‚úó Prompt test failed, fix issues before deploying"
  exit 1
fi
</code></pre>
<h2 id="see-also-1"><a class="header" href="#see-also-1">See Also</a></h2>
<ul>
<li><a href="./cli-search.html"><code>search</code></a> - Find prompts to test</li>
<li><a href="./template-variables.html">Template Variables</a> - Template syntax reference</li>
<li><a href="./testing-guide.html">Testing Guide</a> - Advanced testing strategies</li>
<li><a href="./custom-filters.html">Custom Filters</a> - Available template filters</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="export---export-prompts-for-sharing"><a class="header" href="#export---export-prompts-for-sharing">export - Export Prompts for Sharing</a></h1>
<p>The <code>export</code> command allows you to package and share prompts in various formats for backup, distribution, or collaboration.</p>
<h2 id="synopsis-2"><a class="header" href="#synopsis-2">Synopsis</a></h2>
<pre><code class="language-bash">swissarmyhammer export [OPTIONS] [PROMPTS...] &lt;OUTPUT&gt;
</code></pre>
<h2 id="description-2"><a class="header" href="#description-2">Description</a></h2>
<p>Export prompts to archives, directories, or other formats for sharing, backup, or deployment. Supports exporting individual prompts, categories, or entire collections.</p>
<h2 id="arguments-2"><a class="header" href="#arguments-2">Arguments</a></h2>
<ul>
<li><code>PROMPTS...</code> - Specific prompt IDs to export (optional if using <code>--all</code> or <code>--category</code>)</li>
<li><code>OUTPUT</code> - Output path (file for archives, directory for directory format)</li>
</ul>
<h2 id="options-2"><a class="header" href="#options-2">Options</a></h2>
<h3 id="selection"><a class="header" href="#selection">Selection</a></h3>
<ul>
<li><code>--all, -a</code> - Export all prompts</li>
<li><code>--category, -c CATEGORY</code> - Export prompts from specific category</li>
<li><code>--source SOURCE</code> - Export prompts from specific source (builtin, user, local)</li>
</ul>
<h3 id="format"><a class="header" href="#format">Format</a></h3>
<ul>
<li><code>--format, -f FORMAT</code> - Output format (tar.gz, zip, directory)
<ul>
<li><code>tar.gz</code> - Compressed tar archive (default)</li>
<li><code>zip</code> - ZIP archive</li>
<li><code>directory</code> - Plain directory structure</li>
</ul>
</li>
</ul>
<h3 id="content-control"><a class="header" href="#content-control">Content Control</a></h3>
<ul>
<li><code>--include-metadata</code> - Include metadata files (manifest, checksums)</li>
<li><code>--no-validation</code> - Skip prompt validation before export</li>
<li><code>--exclude-builtin</code> - Exclude built-in prompts from export</li>
</ul>
<h3 id="output-control-2"><a class="header" href="#output-control-2">Output Control</a></h3>
<ul>
<li><code>--dry-run</code> - Show what would be exported without creating files</li>
<li><code>--quiet, -q</code> - Suppress progress output</li>
<li><code>--verbose, -v</code> - Show detailed export progress</li>
</ul>
<h2 id="examples-3"><a class="header" href="#examples-3">Examples</a></h2>
<h3 id="basic-export"><a class="header" href="#basic-export">Basic Export</a></h3>
<pre><code class="language-bash"># Export specific prompts to tar.gz
swissarmyhammer export code-review debug-helper exported-prompts.tar.gz

# Export all prompts
swissarmyhammer export --all my-prompts.tar.gz

# Export to directory
swissarmyhammer export --all --format directory ./prompt-backup/
</code></pre>
<h3 id="category-and-source-export"><a class="header" href="#category-and-source-export">Category and Source Export</a></h3>
<pre><code class="language-bash"># Export all review-related prompts
swissarmyhammer export --category review review-prompts.zip

# Export only user-created prompts
swissarmyhammer export --source user --format tar.gz user-prompts.tar.gz

# Export local project prompts
swissarmyhammer export --source local project-prompts.tar.gz
</code></pre>
<h3 id="advanced-options"><a class="header" href="#advanced-options">Advanced Options</a></h3>
<pre><code class="language-bash"># Dry run to see what would be exported
swissarmyhammer export --all --dry-run backup.tar.gz

# Export with metadata and validation
swissarmyhammer export --all --include-metadata --verbose complete-backup.tar.gz

# Export excluding built-ins
swissarmyhammer export --all --exclude-builtin custom-prompts.tar.gz
</code></pre>
<h2 id="export-formats"><a class="header" href="#export-formats">Export Formats</a></h2>
<h3 id="targz-default"><a class="header" href="#targz-default">tar.gz (Default)</a></h3>
<ul>
<li><strong>Benefits</strong>: Widely supported, good compression, preserves permissions</li>
<li><strong>Use case</strong>: Sharing collections, backup, CI/CD pipelines</li>
<li><strong>File structure</strong>: Flat or hierarchical based on source organization</li>
</ul>
<h3 id="zip"><a class="header" href="#zip">zip</a></h3>
<ul>
<li><strong>Benefits</strong>: Native support on Windows, good tool ecosystem</li>
<li><strong>Use case</strong>: Sharing with Windows users, web distribution</li>
<li><strong>File structure</strong>: Same as tar.gz but in ZIP format</li>
</ul>
<h3 id="directory"><a class="header" href="#directory">directory</a></h3>
<ul>
<li><strong>Benefits</strong>: Easy to browse, no extraction needed, version control friendly</li>
<li><strong>Use case</strong>: Local backup, development, manual inspection</li>
<li><strong>File structure</strong>: Mirrors the original prompt directory organization</li>
</ul>
<h2 id="output-structure"><a class="header" href="#output-structure">Output Structure</a></h2>
<h3 id="archive-formats-targz-zip"><a class="header" href="#archive-formats-targz-zip">Archive Formats (tar.gz, zip)</a></h3>
<pre><code>exported-prompts.tar.gz/
‚îú‚îÄ‚îÄ manifest.json                 # Export metadata
‚îú‚îÄ‚îÄ checksums.sha256             # File integrity checks
‚îú‚îÄ‚îÄ prompts/
‚îÇ   ‚îú‚îÄ‚îÄ review/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ code.md
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ security.md
‚îÇ   ‚îú‚îÄ‚îÄ debug/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ error.md
‚îÇ   ‚îî‚îÄ‚îÄ docs/
‚îÇ       ‚îî‚îÄ‚îÄ api.md
‚îî‚îÄ‚îÄ README.md                    # Export information
</code></pre>
<h3 id="directory-format"><a class="header" href="#directory-format">Directory Format</a></h3>
<pre><code>prompt-backup/
‚îú‚îÄ‚îÄ .swissarmyhammer/
‚îÇ   ‚îú‚îÄ‚îÄ manifest.json           # Export metadata
‚îÇ   ‚îî‚îÄ‚îÄ checksums.sha256        # File integrity
‚îú‚îÄ‚îÄ prompts/
‚îÇ   ‚îú‚îÄ‚îÄ review/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ code.md
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ security.md
‚îÇ   ‚îî‚îÄ‚îÄ debug/
‚îÇ       ‚îî‚îÄ‚îÄ error.md
‚îî‚îÄ‚îÄ README.md                   # Export information
</code></pre>
<h2 id="metadata-files"><a class="header" href="#metadata-files">Metadata Files</a></h2>
<h3 id="manifestjson"><a class="header" href="#manifestjson">manifest.json</a></h3>
<pre><code class="language-json">{
  "exported_at": "2024-01-15T10:30:00Z",
  "swissarmyhammer_version": "0.1.0",
  "export_options": {
    "format": "tar.gz",
    "include_builtin": false,
    "sources": ["user", "local"]
  },
  "prompts": [
    {
      "id": "code-review",
      "title": "Code Review Helper",
      "source": "user",
      "path": "prompts/review/code.md",
      "checksum": "sha256:abc123...",
      "arguments": ["code", "language"]
    }
  ],
  "statistics": {
    "total_prompts": 15,
    "total_size": "45.2KB",
    "categories": ["review", "debug", "docs"]
  }
}
</code></pre>
<h3 id="checksumssha256"><a class="header" href="#checksumssha256">checksums.sha256</a></h3>
<pre><code>abc123... prompts/review/code.md
def456... prompts/debug/error.md
ghi789... prompts/docs/api.md
</code></pre>
<h2 id="export-validation"><a class="header" href="#export-validation">Export Validation</a></h2>
<p>Before export, prompts are validated for:</p>
<ul>
<li><strong>Syntax</strong>: Valid YAML front matter and Markdown structure</li>
<li><strong>Templates</strong>: Liquid template syntax correctness</li>
<li><strong>Arguments</strong>: Argument definitions match template usage</li>
<li><strong>References</strong>: No broken internal references or includes</li>
</ul>
<p>Skip validation with <code>--no-validation</code> for faster exports or when dealing with known issues.</p>
<h2 id="performance-and-size"><a class="header" href="#performance-and-size">Performance and Size</a></h2>
<h3 id="compression-ratios"><a class="header" href="#compression-ratios">Compression Ratios</a></h3>
<ul>
<li><strong>tar.gz</strong>: 70-80% size reduction for typical prompt collections</li>
<li><strong>zip</strong>: 65-75% size reduction, faster compression</li>
<li><strong>directory</strong>: No compression, fastest export</li>
</ul>
<h3 id="performance-tips"><a class="header" href="#performance-tips">Performance Tips</a></h3>
<pre><code class="language-bash"># For large collections, use parallel processing
export RAYON_NUM_THREADS=4
swissarmyhammer export --all large-collection.tar.gz

# For frequent exports, skip validation
swissarmyhammer export --all --no-validation quick-backup.tar.gz
</code></pre>
<h2 id="integration-examples-1"><a class="header" href="#integration-examples-1">Integration Examples</a></h2>
<h3 id="backup-script"><a class="header" href="#backup-script">Backup Script</a></h3>
<pre><code class="language-bash">#!/bin/bash
# backup-prompts.sh

DATE=$(date +%Y%m%d)
BACKUP_DIR="$HOME/prompt-backups"
mkdir -p "$BACKUP_DIR"

echo "Creating daily prompt backup..."
swissarmyhammer export --all \
  --include-metadata \
  --format tar.gz \
  "$BACKUP_DIR/prompts-$DATE.tar.gz"

# Keep only last 30 days
find "$BACKUP_DIR" -name "prompts-*.tar.gz" -mtime +30 -delete

echo "Backup complete: $BACKUP_DIR/prompts-$DATE.tar.gz"
</code></pre>
<h3 id="cicd-pipeline"><a class="header" href="#cicd-pipeline">CI/CD Pipeline</a></h3>
<pre><code class="language-yaml"># .github/workflows/export-prompts.yml
name: Export Prompts
on:
  push:
    tags: ['v*']

jobs:
  export:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Install SwissArmyHammer
        run: cargo install --git https://github.com/wballard/swissarmyhammer.git swissarmyhammer-cli
      - name: Export prompts
        run: |
          swissarmyhammer export --all \
            --exclude-builtin \
            --format tar.gz \
            prompts-${GITHUB_REF#refs/tags/}.tar.gz
      - name: Upload release asset
        uses: actions/upload-release-asset@v1
        with:
          upload_url: ${{ github.event.release.upload_url }}
          asset_path: ./prompts-*.tar.gz
          asset_name: prompts-${{ github.ref }}.tar.gz
          asset_content_type: application/gzip
</code></pre>
<h3 id="team-sharing"><a class="header" href="#team-sharing">Team Sharing</a></h3>
<pre><code class="language-bash"># Export team prompts for sharing
swissarmyhammer export \
  --category "team" \
  --include-metadata \
  team-prompts-$(date +%Y%m%d).tar.gz

# Upload to shared location
scp team-prompts-*.tar.gz team@shared-server:/shared/prompts/
</code></pre>
<h2 id="see-also-2"><a class="header" href="#see-also-2">See Also</a></h2>
<ul>
<li><a href="./cli-import.html"><code>import</code></a> - Import exported prompts</li>
<li><a href="./sharing-guide.html">Sharing Guide</a> - Collaboration workflows</li>
<li><a href="./cli-search.html"><code>search</code></a> - Find prompts to export</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="import---import-prompts-from-various-sources"><a class="header" href="#import---import-prompts-from-various-sources">import - Import Prompts from Various Sources</a></h1>
<p>The <code>import</code> command allows you to import prompts from archives, URLs, Git repositories, and other sources into your local prompt collection.</p>
<h2 id="synopsis-3"><a class="header" href="#synopsis-3">Synopsis</a></h2>
<pre><code class="language-bash">swissarmyhammer import [OPTIONS] &lt;SOURCE&gt;
</code></pre>
<h2 id="description-3"><a class="header" href="#description-3">Description</a></h2>
<p>Import prompts from various sources including local files, URLs, Git repositories, and other SwissArmyHammer installations. Supports conflict resolution, validation, and backup creation.</p>
<h2 id="arguments-3"><a class="header" href="#arguments-3">Arguments</a></h2>
<ul>
<li><code>SOURCE</code> - Import source (file path, URL, Git repository, or directory)</li>
</ul>
<h2 id="options-3"><a class="header" href="#options-3">Options</a></h2>
<h3 id="conflict-resolution"><a class="header" href="#conflict-resolution">Conflict Resolution</a></h3>
<ul>
<li><code>--strategy STRATEGY</code> - Conflict resolution strategy
<ul>
<li><code>ask</code> - Prompt for each conflict (default)</li>
<li><code>overwrite</code> - Overwrite existing prompts</li>
<li><code>skip</code> - Skip conflicting prompts</li>
<li><code>rename</code> - Rename conflicting prompts</li>
<li><code>abort</code> - Abort on first conflict</li>
</ul>
</li>
</ul>
<h3 id="source-options"><a class="header" href="#source-options">Source Options</a></h3>
<ul>
<li><code>--git-branch BRANCH</code> - Git branch to import from (for Git sources)</li>
<li><code>--git-path PATH</code> - Path within Git repository to import</li>
<li><code>--extract-to DIR</code> - Extract archives to specific directory first</li>
</ul>
<h3 id="validation-and-safety"><a class="header" href="#validation-and-safety">Validation and Safety</a></h3>
<ul>
<li><code>--dry-run</code> - Show what would be imported without making changes</li>
<li><code>--no-backup</code> - Skip creating backup before import</li>
<li><code>--no-validation</code> - Skip prompt validation during import</li>
<li><code>--force</code> - Force import even with validation errors</li>
</ul>
<h3 id="output-control-3"><a class="header" href="#output-control-3">Output Control</a></h3>
<ul>
<li><code>--quiet, -q</code> - Suppress progress output</li>
<li><code>--verbose, -v</code> - Show detailed import progress</li>
<li><code>--json</code> - Output results in JSON format</li>
</ul>
<h2 id="examples-4"><a class="header" href="#examples-4">Examples</a></h2>
<h3 id="file-import"><a class="header" href="#file-import">File Import</a></h3>
<pre><code class="language-bash"># Import from local archive
swissarmyhammer import prompts-backup.tar.gz

# Import from directory
swissarmyhammer import ./shared-prompts/

# Import with specific conflict strategy
swissarmyhammer import --strategy overwrite team-prompts.zip
</code></pre>
<h3 id="url-import"><a class="header" href="#url-import">URL Import</a></h3>
<pre><code class="language-bash"># Import from URL
swissarmyhammer import https://example.com/prompts.tar.gz

# Import from GitHub release
swissarmyhammer import https://github.com/team/prompts/releases/download/v1.0/prompts.tar.gz
</code></pre>
<h3 id="git-repository-import"><a class="header" href="#git-repository-import">Git Repository Import</a></h3>
<pre><code class="language-bash"># Import from Git repository
swissarmyhammer import https://github.com/team/prompt-library.git

# Import specific branch
swissarmyhammer import --git-branch develop https://github.com/team/prompts.git

# Import specific path within repository
swissarmyhammer import --git-path prompts/ https://github.com/team/project.git
</code></pre>
<h3 id="advanced-import"><a class="header" href="#advanced-import">Advanced Import</a></h3>
<pre><code class="language-bash"># Dry run to preview import
swissarmyhammer import --dry-run team-prompts.tar.gz

# Import with validation and backup
swissarmyhammer import --verbose --strategy ask prompts.tar.gz

# Force import with errors
swissarmyhammer import --force --no-validation broken-prompts.tar.gz
</code></pre>
<h2 id="import-sources"><a class="header" href="#import-sources">Import Sources</a></h2>
<h3 id="supported-formats"><a class="header" href="#supported-formats">Supported Formats</a></h3>
<ul>
<li><strong>tar.gz</strong> - Compressed tar archives</li>
<li><strong>zip</strong> - ZIP archives</li>
<li><strong>directory</strong> - Local directories</li>
<li><strong>Git repositories</strong> - Remote Git repositories</li>
<li><strong>URLs</strong> - HTTP/HTTPS downloads</li>
</ul>
<h3 id="auto-detection"><a class="header" href="#auto-detection">Auto-Detection</a></h3>
<p>SwissArmyHammer automatically detects source types:</p>
<pre><code class="language-bash"># These are all detected automatically
swissarmyhammer import prompts.tar.gz           # Archive
swissarmyhammer import ./prompts/               # Directory
swissarmyhammer import https://example.com/prompts.tar.gz  # URL
swissarmyhammer import git@github.com:team/prompts.git     # Git SSH
swissarmyhammer import https://github.com/team/prompts.git # Git HTTPS
</code></pre>
<h2 id="conflict-resolution-1"><a class="header" href="#conflict-resolution-1">Conflict Resolution</a></h2>
<h3 id="interactive-mode-ask"><a class="header" href="#interactive-mode-ask">Interactive Mode (ask)</a></h3>
<pre><code class="language-bash">$ swissarmyhammer import team-prompts.tar.gz
Found 3 prompts to import, 1 conflict detected.

Conflict: 'code-review' already exists
Existing: User prompt from ~/.swissarmyhammer/prompts/review/code.md
Incoming: Team prompt "Advanced Code Review Helper"

? How should this conflict be resolved?
  &gt; View differences
    Overwrite existing
    Skip this prompt  
    Rename to 'code-review-team'
    Rename to 'code-review-2'
    Abort import
</code></pre>
<h3 id="automatic-strategies"><a class="header" href="#automatic-strategies">Automatic Strategies</a></h3>
<pre><code class="language-bash"># Overwrite all conflicts
swissarmyhammer import --strategy overwrite prompts.tar.gz

# Skip all conflicts
swissarmyhammer import --strategy skip prompts.tar.gz

# Rename all conflicts
swissarmyhammer import --strategy rename prompts.tar.gz
</code></pre>
<h2 id="validation-and-safety-1"><a class="header" href="#validation-and-safety-1">Validation and Safety</a></h2>
<h3 id="pre-import-validation"><a class="header" href="#pre-import-validation">Pre-Import Validation</a></h3>
<pre><code class="language-bash">$ swissarmyhammer import --dry-run prompts.tar.gz
Import Analysis:
‚úì Archive format: tar.gz (valid)
‚úì Manifest present and valid
‚úì Checksums verified

Prompts to import:
  ‚úì code-review (valid template)
  ‚úì debug-helper (valid template)  
  ‚ö† broken-prompt (warning: unused argument 'old_arg')
  ‚úó invalid-prompt (error: invalid YAML front matter)

Conflicts:
  ! code-review - conflicts with existing user prompt

Summary: 2 valid, 1 warning, 1 error, 1 conflict
Would import 3 prompts (excluding invalid)
</code></pre>
<h3 id="backup-creation"><a class="header" href="#backup-creation">Backup Creation</a></h3>
<pre><code class="language-bash"># Automatic backup before import
$ swissarmyhammer import prompts.tar.gz
Creating backup: ~/.swissarmyhammer/backups/pre-import-20240115-103000.tar.gz
Importing 3 prompts...
‚úì Import completed successfully

# Restore from backup if needed
swissarmyhammer import ~/.swissarmyhammer/backups/pre-import-20240115-103000.tar.gz --strategy overwrite
</code></pre>
<h2 id="import-structure"><a class="header" href="#import-structure">Import Structure</a></h2>
<h3 id="expected-directory-structure"><a class="header" href="#expected-directory-structure">Expected Directory Structure</a></h3>
<pre><code>prompts-archive.tar.gz/
‚îú‚îÄ‚îÄ manifest.json              # Optional metadata
‚îú‚îÄ‚îÄ prompts/                   # Prompt files
‚îÇ   ‚îú‚îÄ‚îÄ review/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ code.md
‚îÇ   ‚îî‚îÄ‚îÄ debug/
‚îÇ       ‚îî‚îÄ‚îÄ error.md
‚îî‚îÄ‚îÄ README.md                  # Optional documentation
</code></pre>
<h3 id="flexible-structure-support"><a class="header" href="#flexible-structure-support">Flexible Structure Support</a></h3>
<p>SwissArmyHammer handles various directory structures:</p>
<pre><code class="language-bash"># All these structures are supported:
./prompts/*.md                 # Flat structure
./category/*/prompt.md         # Nested categories
./src/prompts/**/*.md         # Deep nesting
./random-structure/**/*.md     # Any structure with .md files
</code></pre>
<h2 id="git-integration"><a class="header" href="#git-integration">Git Integration</a></h2>
<h3 id="authentication"><a class="header" href="#authentication">Authentication</a></h3>
<pre><code class="language-bash"># SSH key authentication (recommended)
swissarmyhammer import git@github.com:team/prompts.git

# HTTPS with credentials
export GIT_USERNAME=user
export GIT_PASSWORD=token
swissarmyhammer import https://github.com/team/prompts.git

# GitHub CLI integration
gh auth login
swissarmyhammer import https://github.com/private/prompts.git
</code></pre>
<h3 id="branch-and-path-selection"><a class="header" href="#branch-and-path-selection">Branch and Path Selection</a></h3>
<pre><code class="language-bash"># Import from specific branch
swissarmyhammer import --git-branch feature/new-prompts \
  https://github.com/team/prompts.git

# Import only specific directory
swissarmyhammer import --git-path specialized-prompts/ \
  https://github.com/team/monorepo.git

# Combine branch and path
swissarmyhammer import \
  --git-branch develop \
  --git-path prompts/production/ \
  https://github.com/team/project.git
</code></pre>
<h2 id="output-and-logging"><a class="header" href="#output-and-logging">Output and Logging</a></h2>
<h3 id="progress-output"><a class="header" href="#progress-output">Progress Output</a></h3>
<pre><code class="language-bash">$ swissarmyhammer import --verbose prompts.tar.gz
Downloading: prompts.tar.gz (1.2MB) [‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà] 100%
Extracting archive...
Validating 5 prompts...
  ‚úì code-review (valid)
  ‚úì debug-helper (valid)
  ‚úì api-docs (valid)
  ‚ö† legacy-prompt (deprecated syntax)
  ‚úó broken-template (invalid liquid syntax)

Importing valid prompts:
  ‚Üí code-review (new)
  ‚Üí debug-helper (conflict: renamed to debug-helper-imported)
  ‚Üí api-docs (new)
  ‚Üí legacy-prompt (new, with warnings)

Skipped: 1 invalid prompt
Imported: 4 prompts
Conflicts resolved: 1
</code></pre>
<h3 id="json-output-1"><a class="header" href="#json-output-1">JSON Output</a></h3>
<pre><code class="language-bash">$ swissarmyhammer import --json prompts.tar.gz
{
  "success": true,
  "imported": 4,
  "skipped": 1,
  "conflicts": 1,
  "backup_created": "~/.swissarmyhammer/backups/pre-import-20240115-103000.tar.gz",
  "prompts": [
    {
      "id": "code-review",
      "action": "imported",
      "source_path": "prompts/review/code.md",
      "target_path": "~/.swissarmyhammer/prompts/review/code.md"
    },
    {
      "id": "debug-helper", 
      "action": "renamed",
      "original_id": "debug-helper",
      "new_id": "debug-helper-imported",
      "reason": "conflict_resolution"
    }
  ],
  "errors": [
    {
      "prompt": "broken-template",
      "error": "Invalid Liquid syntax at line 15",
      "action": "skipped"
    }
  ]
}
</code></pre>
<h2 id="integration-examples-2"><a class="header" href="#integration-examples-2">Integration Examples</a></h2>
<h3 id="team-onboarding"><a class="header" href="#team-onboarding">Team Onboarding</a></h3>
<pre><code class="language-bash">#!/bin/bash
# onboard-developer.sh

echo "Setting up SwissArmyHammer with team prompts..."

# Import base team prompts
swissarmyhammer import \
  --strategy ask \
  https://github.com/company/team-prompts.git

# Import project-specific prompts  
swissarmyhammer import \
  --strategy skip \
  https://github.com/company/project-prompts/releases/latest/download/prompts.tar.gz

echo "‚úì Prompt setup complete"
echo "Use 'swissarmyhammer doctor' to verify installation"
</code></pre>
<h3 id="continuous-integration"><a class="header" href="#continuous-integration">Continuous Integration</a></h3>
<pre><code class="language-yaml"># .github/workflows/sync-prompts.yml
name: Sync Team Prompts
on:
  schedule:
    - cron: '0 9 * * MON'  # Weekly sync

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
      - name: Install SwissArmyHammer
        run: cargo install --git https://github.com/wballard/swissarmyhammer.git swissarmyhammer-cli
      
      - name: Import latest team prompts
        run: |
          swissarmyhammer import \
            --strategy overwrite \
            --no-backup \
            https://github.com/company/team-prompts.git
      
      - name: Validate imported prompts
        run: swissarmyhammer doctor
</code></pre>
<h3 id="migration-script"><a class="header" href="#migration-script">Migration Script</a></h3>
<pre><code class="language-bash">#!/bin/bash
# migrate-from-old-system.sh

OLD_PROMPTS="/old-system/prompts"
BACKUP_DIR="/backup/prompts-$(date +%Y%m%d)"

echo "Migrating prompts from old system..."

# Create backup
mkdir -p "$BACKUP_DIR"
cp -r "$OLD_PROMPTS" "$BACKUP_DIR/"

# Convert and import
for file in "$OLD_PROMPTS"/*.txt; do
  # Convert old format to SwissArmyHammer format
  ./convert-prompt.py "$file" &gt; "converted/$(basename "$file" .txt).md"
done

# Import converted prompts
swissarmyhammer import converted/ --strategy ask

echo "Migration complete. Backup at: $BACKUP_DIR"
</code></pre>
<h2 id="see-also-3"><a class="header" href="#see-also-3">See Also</a></h2>
<ul>
<li><a href="./cli-export.html"><code>export</code></a> - Export prompts for sharing</li>
<li><a href="./sharing-guide.html">Sharing Guide</a> - Collaboration workflows</li>
<li><a href="./cli-doctor.html"><code>doctor</code></a> - Validate installation after import</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="doctor"><a class="header" href="#doctor">doctor</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="completion"><a class="header" href="#completion">completion</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-library-guide"><a class="header" href="#rust-library-guide">Rust Library Guide</a></h1>
<p>SwissArmyHammer is available as a Rust library (<code>swissarmyhammer</code>) that you can integrate into your own applications. This guide covers installation, basic usage, and advanced integration patterns.</p>
<h2 id="installation-2"><a class="header" href="#installation-2">Installation</a></h2>
<p>Add SwissArmyHammer to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
swissarmyhammer = { git = "https://github.com/wballard/swissarmyhammer", features = ["full"] }
</code></pre>
<h3 id="feature-flags"><a class="header" href="#feature-flags">Feature Flags</a></h3>
<p>Control which functionality to include:</p>
<pre><code class="language-toml">[dependencies]
swissarmyhammer = { 
  git = "https://github.com/wballard/swissarmyhammer", 
  features = ["prompts", "templates", "search", "mcp"] 
}
</code></pre>
<p>Available features:</p>
<ul>
<li><code>prompts</code> - Core prompt management (always enabled)</li>
<li><code>templates</code> - Liquid template engine with custom filters</li>
<li><code>search</code> - Full-text search capabilities</li>
<li><code>mcp</code> - Model Context Protocol server support</li>
<li><code>storage</code> - Advanced storage backends</li>
<li><code>full</code> - All features enabled</li>
</ul>
<h2 id="quick-start-1"><a class="header" href="#quick-start-1">Quick Start</a></h2>
<h3 id="basic-prompt-library"><a class="header" href="#basic-prompt-library">Basic Prompt Library</a></h3>
<pre><code class="language-rust">use swissarmyhammer::{PromptLibrary, ArgumentSpec};
use std::collections::HashMap;

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Create a new prompt library
    let mut library = PromptLibrary::new();
    
    // Add prompts from a directory
    library.add_directory("./prompts").await?;
    
    // List available prompts
    for prompt_id in library.list_prompts() {
        println!("Available prompt: {}", prompt_id);
    }
    
    // Get a specific prompt
    let prompt = library.get("code-review")?;
    println!("Title: {}", prompt.title());
    println!("Description: {}", prompt.description());
    
    // Prepare arguments
    let mut args = HashMap::new();
    args.insert("code".to_string(), "fn main() { println!(\"Hello\"); }".to_string());
    args.insert("language".to_string(), "rust".to_string());
    
    // Render the prompt
    let rendered = prompt.render(&amp;args)?;
    println!("Rendered prompt:\n{}", rendered);
    
    Ok(())
}</code></pre>
<h3 id="custom-prompt-creation"><a class="header" href="#custom-prompt-creation">Custom Prompt Creation</a></h3>
<pre><code class="language-rust">use swissarmyhammer::{Prompt, ArgumentSpec, PromptMetadata};

fn create_custom_prompt() -&gt; Result&lt;Prompt, Box&lt;dyn std::error::Error&gt;&gt; {
    let metadata = PromptMetadata {
        title: "Custom Code Review".to_string(),
        description: "A custom code review prompt".to_string(),
        arguments: vec![
            ArgumentSpec {
                name: "code".to_string(),
                description: "Code to review".to_string(),
                required: true,
                default: None,
            },
            ArgumentSpec {
                name: "focus".to_string(),
                description: "Review focus area".to_string(),
                required: false,
                default: Some("general".to_string()),
            },
        ],
    };
    
    let template = r#"
<span class="boring">Code Review: {{ focus | capitalize }}
</span>
Please review this code:
</code></pre>
<p>{{ code }}</p>
<pre><code>
{% if focus == "security" %}
Focus specifically on security vulnerabilities and best practices.
{% elsif focus == "performance" %}
Focus on performance optimizations and efficiency.
{% else %}
Perform a general code review covering style, bugs, and maintainability.
{% endif %}
"#;
    
    Prompt::from_parts(metadata, template)
}
</code></pre>
<h2 id="core-components"><a class="header" href="#core-components">Core Components</a></h2>
<h3 id="promptlibrary"><a class="header" href="#promptlibrary">PromptLibrary</a></h3>
<p>The main interface for managing collections of prompts.</p>
<pre><code class="language-rust">use swissarmyhammer::PromptLibrary;

let mut library = PromptLibrary::new();

// Add prompts from various sources
library.add_directory("./prompts").await?;
library.add_file("./special-prompt.md").await?;
library.add_builtin_prompts();

// Query prompts
let prompts = library.list_prompts();
let prompt = library.get("prompt-id")?;
let filtered = library.filter_by_category("review");

// Search prompts
let results = library.search("code review")?;</code></pre>
<h3 id="prompt"><a class="header" href="#prompt">Prompt</a></h3>
<p>Individual prompt with metadata and template.</p>
<pre><code class="language-rust">use swissarmyhammer::Prompt;

// Load from file
let prompt = Prompt::from_file("./prompts/review.md").await?;

// Access metadata
println!("Title: {}", prompt.title());
println!("Description: {}", prompt.description());
for arg in prompt.arguments() {
    println!("Argument: {} (required: {})", arg.name, arg.required);
}

// Render with arguments
let mut args = HashMap::new();
args.insert("code".to_string(), "example code".to_string());
let rendered = prompt.render(&amp;args)?;</code></pre>
<h3 id="template-engine"><a class="header" href="#template-engine">Template Engine</a></h3>
<p>Advanced template processing with custom filters.</p>
<pre><code class="language-rust">use swissarmyhammer::template::{TemplateEngine, TemplateContext};

let engine = TemplateEngine::new();

let template = "Hello {{ name | capitalize }}! Today is {{ 'now' | format_date: '%Y-%m-%d' }}.";

let mut context = TemplateContext::new();
context.insert("name", "alice");

let result = engine.render(template, &amp;context)?;
println!("{}", result); // "Hello Alice! Today is 2024-01-15."</code></pre>
<h2 id="advanced-usage"><a class="header" href="#advanced-usage">Advanced Usage</a></h2>
<h3 id="custom-storage-backend"><a class="header" href="#custom-storage-backend">Custom Storage Backend</a></h3>
<p>Implement your own storage for prompts:</p>
<pre><code class="language-rust">use swissarmyhammer::storage::{StorageBackend, PromptSource};
use async_trait::async_trait;

struct DatabaseStorage {
    // Your database connection
    db: Database,
}

#[async_trait]
impl StorageBackend for DatabaseStorage {
    async fn list_prompts(&amp;self) -&gt; Result&lt;Vec&lt;String&gt;, StorageError&gt; {
        // Implement database query
        todo!()
    }
    
    async fn get_prompt(&amp;self, id: &amp;str) -&gt; Result&lt;PromptSource, StorageError&gt; {
        // Implement database retrieval
        todo!()
    }
    
    async fn save_prompt(&amp;mut self, id: &amp;str, source: &amp;PromptSource) -&gt; Result&lt;(), StorageError&gt; {
        // Implement database storage
        todo!()
    }
}

// Use custom storage
let storage = DatabaseStorage::new(db);
let mut library = PromptLibrary::with_storage(storage);</code></pre>
<h3 id="search-integration"><a class="header" href="#search-integration">Search Integration</a></h3>
<p>Advanced search capabilities:</p>
<pre><code class="language-rust">use swissarmyhammer::search::{SearchEngine, SearchQuery, SearchResult};

let mut search_engine = SearchEngine::new();

// Index prompts
search_engine.index_prompt("code-review", &amp;prompt).await?;

// Perform searches
let query = SearchQuery::new("code review")
    .with_field("title")
    .with_limit(10)
    .case_sensitive(false);

let results: Vec&lt;SearchResult&gt; = search_engine.search(&amp;query)?;

for result in results {
    println!("Found: {} (score: {:.2})", result.id, result.score);
}</code></pre>
<h3 id="mcp-server-integration"><a class="header" href="#mcp-server-integration">MCP Server Integration</a></h3>
<p>Embed MCP server functionality:</p>
<pre><code class="language-rust">use swissarmyhammer::mcp::{McpServer, McpConfig};

let config = McpConfig {
    name: "my-prompt-server".to_string(),
    version: "1.0.0".to_string(),
    // ... other config
};

let mut library = PromptLibrary::new();
library.add_directory("./prompts").await?;

let server = McpServer::new(config, library);

// Run MCP server
server.serve().await?;</code></pre>
<h3 id="event-system"><a class="header" href="#event-system">Event System</a></h3>
<p>React to library events:</p>
<pre><code class="language-rust">use swissarmyhammer::events::{EventHandler, PromptEvent};

struct MyEventHandler;

impl EventHandler for MyEventHandler {
    fn handle_prompt_added(&amp;self, id: &amp;str) {
        println!("Prompt added: {}", id);
    }
    
    fn handle_prompt_updated(&amp;self, id: &amp;str) {
        println!("Prompt updated: {}", id);
    }
    
    fn handle_prompt_removed(&amp;self, id: &amp;str) {
        println!("Prompt removed: {}", id);
    }
}

let mut library = PromptLibrary::new();
library.add_event_handler(Box::new(MyEventHandler));</code></pre>
<h3 id="file-watching"><a class="header" href="#file-watching">File Watching</a></h3>
<p>Automatically reload prompts when files change:</p>
<pre><code class="language-rust">use swissarmyhammer::watcher::FileWatcher;

let mut library = PromptLibrary::new();
library.add_directory("./prompts").await?;

// Start watching for file changes
let _watcher = FileWatcher::new("./prompts", move |event| {
    match event {
        FileEvent::Created(path) =&gt; {
            if let Err(e) = library.reload_file(&amp;path) {
                eprintln!("Failed to load {}: {}", path.display(), e);
            }
        }
        FileEvent::Modified(path) =&gt; {
            if let Err(e) = library.reload_file(&amp;path) {
                eprintln!("Failed to reload {}: {}", path.display(), e);
            }
        }
        FileEvent::Deleted(path) =&gt; {
            library.remove_file(&amp;path);
        }
    }
});

// Keep the watcher alive
std::thread::sleep(std::time::Duration::from_secs(60));</code></pre>
<h2 id="integration-examples-3"><a class="header" href="#integration-examples-3">Integration Examples</a></h2>
<h3 id="web-server-integration"><a class="header" href="#web-server-integration">Web Server Integration</a></h3>
<pre><code class="language-rust">use axum::{extract::Path, http::StatusCode, response::Json, routing::get, Router};
use swissarmyhammer::PromptLibrary;
use std::sync::Arc;
use tokio::sync::RwLock;

type SharedLibrary = Arc&lt;RwLock&lt;PromptLibrary&gt;&gt;;

async fn list_prompts(library: SharedLibrary) -&gt; Json&lt;Vec&lt;String&gt;&gt; {
    let lib = library.read().await;
    Json(lib.list_prompts())
}

async fn get_prompt(
    Path(id): Path&lt;String&gt;,
    library: SharedLibrary,
) -&gt; Result&lt;Json&lt;String&gt;, StatusCode&gt; {
    let lib = library.read().await;
    match lib.get(&amp;id) {
        Ok(prompt) =&gt; Ok(Json(prompt.title().to_string())),
        Err(_) =&gt; Err(StatusCode::NOT_FOUND),
    }
}

#[tokio::main]
async fn main() {
    let mut library = PromptLibrary::new();
    library.add_directory("./prompts").await.unwrap();
    let shared_library = Arc::new(RwLock::new(library));

    let app = Router::new()
        .route("/prompts", get({
            let lib = shared_library.clone();
            move || list_prompts(lib)
        }))
        .route("/prompts/:id", get({
            let lib = shared_library.clone();
            move |path| get_prompt(path, lib)
        }));

    axum::Server::bind(&amp;"0.0.0.0:3000".parse().unwrap())
        .serve(app.into_make_service())
        .await
        .unwrap();
}</code></pre>
<h3 id="cli-tool-integration"><a class="header" href="#cli-tool-integration">CLI Tool Integration</a></h3>
<pre><code class="language-rust">use clap::{Arg, Command};
use swissarmyhammer::PromptLibrary;

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let matches = Command::new("my-prompt-tool")
        .arg(Arg::new("prompt")
            .help("Prompt ID to render")
            .required(true)
            .index(1))
        .arg(Arg::new("args")
            .help("Template arguments as key=value pairs")
            .multiple_values(true)
            .short('a')
            .long("arg"))
        .get_matches();

    let mut library = PromptLibrary::new();
    library.add_directory("./prompts").await?;

    let prompt_id = matches.value_of("prompt").unwrap();
    let prompt = library.get(prompt_id)?;

    let mut args = std::collections::HashMap::new();
    if let Some(arg_values) = matches.values_of("args") {
        for arg in arg_values {
            if let Some((key, value)) = arg.split_once('=') {
                args.insert(key.to_string(), value.to_string());
            }
        }
    }

    let rendered = prompt.render(&amp;args)?;
    println!("{}", rendered);

    Ok(())
}</code></pre>
<h3 id="configuration-management"><a class="header" href="#configuration-management">Configuration Management</a></h3>
<pre><code class="language-rust">use serde::{Deserialize, Serialize};
use swissarmyhammer::{PromptLibrary, storage::FileSystemStorage};

#[derive(Serialize, Deserialize)]
struct AppConfig {
    prompt_directories: Vec&lt;String&gt;,
    default_arguments: std::collections::HashMap&lt;String, String&gt;,
    search_enabled: bool,
}

impl Default for AppConfig {
    fn default() -&gt; Self {
        Self {
            prompt_directories: vec!["./prompts".to_string()],
            default_arguments: std::collections::HashMap::new(),
            search_enabled: true,
        }
    }
}

async fn setup_library(config: &amp;AppConfig) -&gt; Result&lt;PromptLibrary, Box&lt;dyn std::error::Error&gt;&gt; {
    let mut library = PromptLibrary::new();
    
    for dir in &amp;config.prompt_directories {
        library.add_directory(dir).await?;
    }
    
    if config.search_enabled {
        library.enable_search()?;
    }
    
    Ok(library)
}</code></pre>
<h2 id="error-handling-3"><a class="header" href="#error-handling-3">Error Handling</a></h2>
<p>SwissArmyHammer uses comprehensive error types:</p>
<pre><code class="language-rust">use swissarmyhammer::error::{SwissArmyHammerError, PromptError, TemplateError};

match library.get("nonexistent") {
    Ok(prompt) =&gt; {
        // Handle success
    }
    Err(SwissArmyHammerError::PromptNotFound(id)) =&gt; {
        eprintln!("Prompt '{}' not found", id);
    }
    Err(SwissArmyHammerError::Template(TemplateError::RenderError(msg))) =&gt; {
        eprintln!("Template rendering failed: {}", msg);
    }
    Err(SwissArmyHammerError::Io(io_err)) =&gt; {
        eprintln!("I/O error: {}", io_err);
    }
    Err(e) =&gt; {
        eprintln!("Unexpected error: {}", e);
    }
}</code></pre>
<h2 id="testing"><a class="header" href="#testing">Testing</a></h2>
<p>SwissArmyHammer provides testing utilities:</p>
<pre><code class="language-rust">use swissarmyhammer::testing::{MockPromptLibrary, PromptTestCase};

#[tokio::test]
async fn test_prompt_rendering() {
    let mut library = MockPromptLibrary::new();
    
    let test_case = PromptTestCase::new("test-prompt")
        .with_template("Hello {{ name }}!")
        .with_argument("name", "World")
        .expect_output("Hello World!");
    
    library.add_test_prompt(test_case);
    
    let prompt = library.get("test-prompt").unwrap();
    let mut args = std::collections::HashMap::new();
    args.insert("name".to_string(), "World".to_string());
    
    let result = prompt.render(&amp;args).unwrap();
    assert_eq!(result, "Hello World!");
}</code></pre>
<h2 id="performance-considerations"><a class="header" href="#performance-considerations">Performance Considerations</a></h2>
<h3 id="memory-usage"><a class="header" href="#memory-usage">Memory Usage</a></h3>
<ul>
<li>Prompt libraries cache parsed templates in memory</li>
<li>Large collections may require custom storage backends</li>
<li>Use lazy loading for better memory efficiency</li>
</ul>
<h3 id="concurrency"><a class="header" href="#concurrency">Concurrency</a></h3>
<ul>
<li><code>PromptLibrary</code> is <code>Send + Sync</code> when used with appropriate storage</li>
<li>Template rendering is thread-safe</li>
<li>Consider using <code>Arc&lt;RwLock&lt;PromptLibrary&gt;&gt;</code> for shared access</li>
</ul>
<h3 id="best-practices-1"><a class="header" href="#best-practices-1">Best Practices</a></h3>
<ul>
<li>Prefer batch operations for multiple prompts</li>
<li>Cache rendered templates when arguments don‚Äôt change</li>
<li>Use feature flags to include only needed functionality</li>
<li>Implement proper error handling for production use</li>
</ul>
<h2 id="migration-from-cli"><a class="header" href="#migration-from-cli">Migration from CLI</a></h2>
<p>If you‚Äôre migrating from using the CLI to the library:</p>
<pre><code class="language-rust">// CLI equivalent: swissarmyhammer search "code review"
let results = library.search("code review")?;

// CLI equivalent: swissarmyhammer test prompt-id --arg key=value
let prompt = library.get("prompt-id")?;
let mut args = HashMap::new();
args.insert("key".to_string(), "value".to_string());
let rendered = prompt.render(&amp;args)?;

// CLI equivalent: swissarmyhammer export --all output.tar.gz
library.export_all("output.tar.gz", ExportFormat::TarGz)?;</code></pre>
<h2 id="see-also-4"><a class="header" href="#see-also-4">See Also</a></h2>
<ul>
<li><a href="./library-api.html">Library API Reference</a> - Complete API documentation</li>
<li><a href="./library-examples.html">Integration Examples</a> - More integration patterns</li>
<li><a href="./custom-filters.html">Custom Filters</a> - Template customization</li>
<li><a href="./advanced-prompts.html">Advanced Prompts</a> - Complex template patterns</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="library-api-reference"><a class="header" href="#library-api-reference">Library API Reference</a></h1>
<p>This document provides comprehensive API documentation for the SwissArmyHammer Rust library.</p>
<h2 id="core-types"><a class="header" href="#core-types">Core Types</a></h2>
<h3 id="prompt-1"><a class="header" href="#prompt-1">Prompt</a></h3>
<p>The <code>Prompt</code> struct represents a single prompt with metadata and template content.</p>
<pre><code class="language-rust">pub struct Prompt {
    pub name: String,
    pub content: String,
    pub description: Option&lt;String&gt;,
    pub category: Option&lt;String&gt;,
    pub tags: Vec&lt;String&gt;,
    pub arguments: Vec&lt;ArgumentSpec&gt;,
    pub file_path: Option&lt;PathBuf&gt;,
}</code></pre>
<h4 id="methods"><a class="header" href="#methods">Methods</a></h4>
<ul>
<li><code>new(name: &amp;str, content: &amp;str) -&gt; Self</code> - Create a new prompt</li>
<li><code>with_description(self, description: &amp;str) -&gt; Self</code> - Add a description (builder pattern)</li>
<li><code>with_category(self, category: &amp;str) -&gt; Self</code> - Add a category (builder pattern)</li>
<li><code>add_tag(self, tag: &amp;str) -&gt; Self</code> - Add a tag (builder pattern)</li>
<li><code>add_argument(self, arg: ArgumentSpec) -&gt; Self</code> - Add an argument specification</li>
<li><code>render(&amp;self, args: &amp;HashMap&lt;String, String&gt;) -&gt; Result&lt;String&gt;</code> - Render the prompt with arguments</li>
<li><code>validate_arguments(&amp;self, args: &amp;HashMap&lt;String, String&gt;) -&gt; Result&lt;()&gt;</code> - Validate provided arguments</li>
</ul>
<h4 id="example"><a class="header" href="#example">Example</a></h4>
<pre><code class="language-rust">use swissarmyhammer::{Prompt, ArgumentSpec};
use std::collections::HashMap;

let prompt = Prompt::new("greet", "Hello {{name}}!")
    .with_description("A greeting prompt")
    .add_argument(ArgumentSpec {
        name: "name".to_string(),
        description: Some("Name to greet".to_string()),
        required: true,
        default: None,
        type_hint: Some("string".to_string()),
    });

let mut args = HashMap::new();
args.insert("name".to_string(), "World".to_string());
let result = prompt.render(&amp;args)?;
// result: "Hello World!"</code></pre>
<h3 id="argumentspec"><a class="header" href="#argumentspec">ArgumentSpec</a></h3>
<p>Defines the specification for a prompt argument.</p>
<pre><code class="language-rust">pub struct ArgumentSpec {
    pub name: String,
    pub description: Option&lt;String&gt;,
    pub required: bool,
    pub default: Option&lt;String&gt;,
    pub type_hint: Option&lt;String&gt;,
}</code></pre>
<h3 id="promptlibrary-1"><a class="header" href="#promptlibrary-1">PromptLibrary</a></h3>
<p>The main interface for managing collections of prompts.</p>
<pre><code class="language-rust">pub struct PromptLibrary {
    // internal fields...
}</code></pre>
<h4 id="methods-1"><a class="header" href="#methods-1">Methods</a></h4>
<ul>
<li><code>new() -&gt; Self</code> - Create a new empty library</li>
<li><code>add_directory&lt;P: AsRef&lt;Path&gt;&gt;(&amp;mut self, path: P) -&gt; Result&lt;()&gt;</code> - Load prompts from directory</li>
<li><code>add_prompt(&amp;mut self, prompt: Prompt)</code> - Add a single prompt</li>
<li><code>get(&amp;self, name: &amp;str) -&gt; Result&lt;&amp;Prompt&gt;</code> - Get a prompt by name</li>
<li><code>list_prompts(&amp;self) -&gt; Vec&lt;&amp;Prompt&gt;</code> - List all prompts</li>
<li><code>find_by_category(&amp;self, category: &amp;str) -&gt; Vec&lt;&amp;Prompt&gt;</code> - Find prompts by category</li>
<li><code>find_by_tag(&amp;self, tag: &amp;str) -&gt; Vec&lt;&amp;Prompt&gt;</code> - Find prompts by tag</li>
<li><code>remove(&amp;mut self, name: &amp;str) -&gt; Option&lt;Prompt&gt;</code> - Remove a prompt</li>
</ul>
<h4 id="example-1"><a class="header" href="#example-1">Example</a></h4>
<pre><code class="language-rust">use swissarmyhammer::PromptLibrary;

let mut library = PromptLibrary::new();
library.add_directory("./prompts")?;

let prompt = library.get("code-review")?;
let rendered = prompt.render(&amp;args)?;</code></pre>
<h3 id="promptloader"><a class="header" href="#promptloader">PromptLoader</a></h3>
<p>Handles loading prompts from various sources.</p>
<pre><code class="language-rust">pub struct PromptLoader {
    // internal fields...
}</code></pre>
<h4 id="methods-2"><a class="header" href="#methods-2">Methods</a></h4>
<ul>
<li><code>new() -&gt; Self</code> - Create a new loader</li>
<li><code>load_file&lt;P: AsRef&lt;Path&gt;&gt;(&amp;self, path: P) -&gt; Result&lt;Prompt&gt;</code> - Load single prompt file</li>
<li><code>load_directory&lt;P: AsRef&lt;Path&gt;&gt;(&amp;self, path: P) -&gt; Result&lt;Vec&lt;Prompt&gt;&gt;</code> - Load all prompts from directory</li>
<li><code>load_string(&amp;self, name: &amp;str, content: &amp;str) -&gt; Result&lt;Prompt&gt;</code> - Load prompt from string</li>
</ul>
<h2 id="template-engine-1"><a class="header" href="#template-engine-1">Template Engine</a></h2>
<h3 id="template"><a class="header" href="#template">Template</a></h3>
<p>Wrapper for Liquid templates with custom filters.</p>
<pre><code class="language-rust">pub struct Template {
    // internal fields...
}</code></pre>
<h4 id="methods-3"><a class="header" href="#methods-3">Methods</a></h4>
<ul>
<li><code>new(template_str: &amp;str) -&gt; Result&lt;Self&gt;</code> - Create template from string</li>
<li><code>render(&amp;self, args: &amp;HashMap&lt;String, String&gt;) -&gt; Result&lt;String&gt;</code> - Render with arguments</li>
<li><code>raw(&amp;self) -&gt; &amp;str</code> - Get the raw template string</li>
</ul>
<h3 id="templateengine"><a class="header" href="#templateengine">TemplateEngine</a></h3>
<p>Manages template parsing and custom filters.</p>
<pre><code class="language-rust">pub struct TemplateEngine {
    // internal fields...
}</code></pre>
<h4 id="methods-4"><a class="header" href="#methods-4">Methods</a></h4>
<ul>
<li><code>new() -&gt; Self</code> - Create new engine</li>
<li><code>default_parser() -&gt; Parser</code> - Get default Liquid parser with custom filters</li>
<li><code>register_filter&lt;F&gt;(&amp;mut self, name: &amp;str, filter: F)</code> - Register custom filter</li>
</ul>
<h2 id="storage"><a class="header" href="#storage">Storage</a></h2>
<h3 id="promptstorage"><a class="header" href="#promptstorage">PromptStorage</a></h3>
<p>High-level storage interface for prompts.</p>
<pre><code class="language-rust">pub trait PromptStorage {
    fn store_prompt(&amp;mut self, prompt: &amp;Prompt) -&gt; Result&lt;()&gt;;
    fn load_prompt(&amp;self, name: &amp;str) -&gt; Result&lt;Prompt&gt;;
    fn list_prompts(&amp;self) -&gt; Result&lt;Vec&lt;String&gt;&gt;;
    fn delete_prompt(&amp;mut self, name: &amp;str) -&gt; Result&lt;()&gt;;
}</code></pre>
<h3 id="storagebackend"><a class="header" href="#storagebackend">StorageBackend</a></h3>
<p>Low-level storage abstraction.</p>
<pre><code class="language-rust">pub trait StorageBackend {
    fn read(&amp;self, key: &amp;str) -&gt; Result&lt;Vec&lt;u8&gt;&gt;;
    fn write(&amp;mut self, key: &amp;str, data: &amp;[u8]) -&gt; Result&lt;()&gt;;
    fn delete(&amp;mut self, key: &amp;str) -&gt; Result&lt;()&gt;;
    fn list(&amp;self) -&gt; Result&lt;Vec&lt;String&gt;&gt;;
}</code></pre>
<h2 id="search"><a class="header" href="#search">Search</a></h2>
<p><em>Available with the <code>search</code> feature</em></p>
<h3 id="searchengine"><a class="header" href="#searchengine">SearchEngine</a></h3>
<p>Full-text search functionality for prompts.</p>
<pre><code class="language-rust">pub struct SearchEngine {
    // internal fields...
}</code></pre>
<h4 id="methods-5"><a class="header" href="#methods-5">Methods</a></h4>
<ul>
<li><code>new() -&gt; Result&lt;Self&gt;</code> - Create new search engine</li>
<li><code>index_prompt(&amp;mut self, prompt: &amp;Prompt) -&gt; Result&lt;()&gt;</code> - Add prompt to search index</li>
<li><code>search(&amp;self, query: &amp;str) -&gt; Result&lt;Vec&lt;SearchResult&gt;&gt;</code> - Search for prompts</li>
</ul>
<h3 id="searchresult"><a class="header" href="#searchresult">SearchResult</a></h3>
<p>Represents a search result.</p>
<pre><code class="language-rust">pub struct SearchResult {
    pub name: String,
    pub score: f32,
    pub snippet: Option&lt;String&gt;,
}</code></pre>
<h2 id="mcp-integration"><a class="header" href="#mcp-integration">MCP Integration</a></h2>
<p><em>Available with the <code>mcp</code> feature</em></p>
<h3 id="mcpserver"><a class="header" href="#mcpserver">McpServer</a></h3>
<p>Model Context Protocol server implementation.</p>
<pre><code class="language-rust">pub struct McpServer {
    // internal fields...
}</code></pre>
<h4 id="methods-6"><a class="header" href="#methods-6">Methods</a></h4>
<ul>
<li><code>new(library: PromptLibrary) -&gt; Self</code> - Create server with prompt library</li>
<li><code>run(&amp;mut self) -&gt; Result&lt;()&gt;</code> - Start the MCP server</li>
</ul>
<h2 id="plugin-system"><a class="header" href="#plugin-system">Plugin System</a></h2>
<h3 id="swissarmyhammerplugin"><a class="header" href="#swissarmyhammerplugin">SwissArmyHammerPlugin</a></h3>
<p>Trait for creating plugins.</p>
<pre><code class="language-rust">pub trait SwissArmyHammerPlugin {
    fn name(&amp;self) -&gt; &amp;str;
    fn filters(&amp;self) -&gt; Vec&lt;Box&lt;dyn CustomLiquidFilter&gt;&gt;;
}</code></pre>
<h3 id="customliquidfilter"><a class="header" href="#customliquidfilter">CustomLiquidFilter</a></h3>
<p>Trait for custom Liquid template filters.</p>
<pre><code class="language-rust">pub trait CustomLiquidFilter {
    fn name(&amp;self) -&gt; &amp;str;
    fn filter(&amp;self, input: &amp;str, args: &amp;[&amp;str]) -&gt; Result&lt;String&gt;;
}</code></pre>
<h3 id="pluginregistry"><a class="header" href="#pluginregistry">PluginRegistry</a></h3>
<p>Manages registered plugins and filters.</p>
<pre><code class="language-rust">pub struct PluginRegistry {
    // internal fields...
}</code></pre>
<h4 id="methods-7"><a class="header" href="#methods-7">Methods</a></h4>
<ul>
<li><code>new() -&gt; Self</code> - Create new registry</li>
<li><code>register_plugin&lt;P: SwissArmyHammerPlugin&gt;(&amp;mut self, plugin: P)</code> - Register plugin</li>
<li><code>get_filters(&amp;self) -&gt; Vec&lt;&amp;dyn CustomLiquidFilter&gt;</code> - Get all registered filters</li>
</ul>
<h2 id="error-handling-4"><a class="header" href="#error-handling-4">Error Handling</a></h2>
<h3 id="swissarmyhammererror"><a class="header" href="#swissarmyhammererror">SwissArmyHammerError</a></h3>
<p>Main error type for the library.</p>
<pre><code class="language-rust">pub enum SwissArmyHammerError {
    Io(std::io::Error),
    Template(String),
    PromptNotFound(String),
    Config(String),
    Storage(String),
    Serialization(serde_yaml::Error),
    Other(String),
}</code></pre>
<h3 id="result-type"><a class="header" href="#result-type">Result Type</a></h3>
<p>Convenient result type alias.</p>
<pre><code class="language-rust">pub type Result&lt;T&gt; = std::result::Result&lt;T, SwissArmyHammerError&gt;;</code></pre>
<h2 id="feature-flags-1"><a class="header" href="#feature-flags-1">Feature Flags</a></h2>
<p>The library supports several optional features:</p>
<ul>
<li><code>search</code> - Enables full-text search functionality</li>
<li><code>mcp</code> - Enables Model Context Protocol server support</li>
</ul>
<p>Enable features in your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
swissarmyhammer = { version = "0.1", features = ["search", "mcp"] }
</code></pre>
<h2 id="complete-example"><a class="header" href="#complete-example">Complete Example</a></h2>
<pre><code class="language-rust">use swissarmyhammer::{PromptLibrary, ArgumentSpec, Result};
use std::collections::HashMap;

fn main() -&gt; Result&lt;()&gt; {
    // Create library and load prompts
    let mut library = PromptLibrary::new();
    library.add_directory("./prompts")?;
    
    // Get a prompt
    let prompt = library.get("code-review")?;
    
    // Prepare arguments
    let mut args = HashMap::new();
    args.insert("code".to_string(), "fn main() { println!(\"Hello\"); }".to_string());
    args.insert("language".to_string(), "rust".to_string());
    
    // Render the prompt
    let rendered = prompt.render(&amp;args)?;
    println!("{}", rendered);
    
    Ok(())
}</code></pre>
<h2 id="advanced-usage-1"><a class="header" href="#advanced-usage-1">Advanced Usage</a></h2>
<h3 id="custom-filters-1"><a class="header" href="#custom-filters-1">Custom Filters</a></h3>
<p>Create custom Liquid filters for domain-specific transformations:</p>
<pre><code class="language-rust">use swissarmyhammer::{CustomLiquidFilter, PluginRegistry, TemplateEngine};

struct UppercaseFilter;

impl CustomLiquidFilter for UppercaseFilter {
    fn name(&amp;self) -&gt; &amp;str { "uppercase" }
    
    fn filter(&amp;self, input: &amp;str, _args: &amp;[&amp;str]) -&gt; Result&lt;String&gt; {
        Ok(input.to_uppercase())
    }
}

let mut registry = PluginRegistry::new();
registry.register_filter("uppercase", Box::new(UppercaseFilter));</code></pre>
<h3 id="storage-backends"><a class="header" href="#storage-backends">Storage Backends</a></h3>
<p>Implement custom storage backends:</p>
<pre><code class="language-rust">use swissarmyhammer::{StorageBackend, Result};

struct DatabaseBackend {
    // database connection...
}

impl StorageBackend for DatabaseBackend {
    fn read(&amp;self, key: &amp;str) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {
        // Read from database
        todo!()
    }
    
    fn write(&amp;mut self, key: &amp;str, data: &amp;[u8]) -&gt; Result&lt;()&gt; {
        // Write to database
        todo!()
    }
    
    // ... implement other methods
}</code></pre>
<p>For more examples and advanced usage patterns, see the <a href="./library-examples.html">Library Examples</a> page.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="integration-examples-4"><a class="header" href="#integration-examples-4">Integration Examples</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-rustdoc-api-documentation"><a class="header" href="#-rustdoc-api-documentation">üîó Rustdoc API Documentation</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced-prompt-techniques"><a class="header" href="#advanced-prompt-techniques">Advanced Prompt Techniques</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="search-and-discovery-guide"><a class="header" href="#search-and-discovery-guide">Search and Discovery Guide</a></h1>
<p>SwissArmyHammer provides powerful search capabilities to help you discover and find prompts in your collection. This guide covers search strategies, advanced filtering, and integration workflows.</p>
<h2 id="basic-search-1"><a class="header" href="#basic-search-1">Basic Search</a></h2>
<h3 id="simple-text-search"><a class="header" href="#simple-text-search">Simple Text Search</a></h3>
<p>The most basic way to search is with a simple text query:</p>
<pre><code class="language-bash"># Search for prompts containing "code"
swissarmyhammer search code

# Search for multiple terms
swissarmyhammer search "code review"

# Search with partial matches
swissarmyhammer search debug
</code></pre>
<h3 id="search-results-format"><a class="header" href="#search-results-format">Search Results Format</a></h3>
<pre><code>Found 3 prompts matching "code":

üìù code-review (builtin)
   Review code for best practices and potential issues
   Arguments: code, language (optional)

üîß debug-helper (user)
   Help debug programming issues and errors
   Arguments: error, context (optional)

üìä analyze-performance (local)
   Analyze code performance and suggest optimizations
   Arguments: code, language, metrics (optional)
</code></pre>
<p>Each result shows:</p>
<ul>
<li><strong>Icon</strong>: Indicates prompt type (üìù builtin, üîß user, üìä local)</li>
<li><strong>Name</strong>: Prompt identifier</li>
<li><strong>Source</strong>: Where the prompt is stored</li>
<li><strong>Description</strong>: Brief description of the prompt‚Äôs purpose</li>
<li><strong>Arguments</strong>: Required and optional parameters</li>
</ul>
<h2 id="field-specific-search-1"><a class="header" href="#field-specific-search-1">Field-Specific Search</a></h2>
<h3 id="search-in-titles-only"><a class="header" href="#search-in-titles-only">Search in Titles Only</a></h3>
<pre><code class="language-bash"># Find prompts with "review" in the title
swissarmyhammer search --in title review

# Case-sensitive title search
swissarmyhammer search --in title --case-sensitive "Code Review"
</code></pre>
<h3 id="search-in-descriptions"><a class="header" href="#search-in-descriptions">Search in Descriptions</a></h3>
<pre><code class="language-bash"># Find prompts about debugging in descriptions
swissarmyhammer search --in description debug

# Find prompts mentioning specific technologies
swissarmyhammer search --in description "python javascript"
</code></pre>
<h3 id="search-in-content"><a class="header" href="#search-in-content">Search in Content</a></h3>
<pre><code class="language-bash"># Find prompts that use specific template variables
swissarmyhammer search --in content "{{code}}"

# Find prompts with specific instructions
swissarmyhammer search --in content "best practices"
</code></pre>
<h3 id="search-all-fields"><a class="header" href="#search-all-fields">Search All Fields</a></h3>
<pre><code class="language-bash"># Search across titles, descriptions, and content (default)
swissarmyhammer search --in all "security"

# Explicit all-field search
swissarmyhammer search "API documentation"
</code></pre>
<h2 id="advanced-search-techniques"><a class="header" href="#advanced-search-techniques">Advanced Search Techniques</a></h2>
<h3 id="regular-expression-search-1"><a class="header" href="#regular-expression-search-1">Regular Expression Search</a></h3>
<p>Use regex patterns for powerful pattern matching:</p>
<pre><code class="language-bash"># Find prompts with "test" followed by any word
swissarmyhammer search --regex "test\s+\w+"

# Find prompts starting with specific words
swissarmyhammer search --regex "^(debug|fix|analyze)"

# Find prompts with email patterns
swissarmyhammer search --regex "\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b"

# Case-sensitive regex
swissarmyhammer search --regex --case-sensitive "^Code"
</code></pre>
<h3 id="search-by-source"><a class="header" href="#search-by-source">Search by Source</a></h3>
<p>Filter prompts by their source location:</p>
<pre><code class="language-bash"># Find only built-in prompts
swissarmyhammer search --source builtin

# Find only user-created prompts
swissarmyhammer search --source user

# Find only local project prompts
swissarmyhammer search --source local

# Combine with text search
swissarmyhammer search review --source user
</code></pre>
<h3 id="search-by-arguments"><a class="header" href="#search-by-arguments">Search by Arguments</a></h3>
<p>Find prompts based on their argument requirements:</p>
<pre><code class="language-bash"># Find prompts that accept a "code" argument
swissarmyhammer search --has-arg code

# Find prompts with no arguments (simple prompts)
swissarmyhammer search --no-args

# Find prompts with specific argument combinations
swissarmyhammer search --has-arg code --has-arg language

# Combine with text search
swissarmyhammer search debug --has-arg error
</code></pre>
<h2 id="search-strategies"><a class="header" href="#search-strategies">Search Strategies</a></h2>
<h3 id="discovery-workflows"><a class="header" href="#discovery-workflows">Discovery Workflows</a></h3>
<h4 id="finding-prompts-for-a-task"><a class="header" href="#finding-prompts-for-a-task">Finding Prompts for a Task</a></h4>
<pre><code class="language-bash"># 1. Start broad
swissarmyhammer search "code review"

# 2. Narrow down by context
swissarmyhammer search "code review" --source user

# 3. Check argument requirements
swissarmyhammer search "code review" --has-arg language

# 4. Examine specific matches
swissarmyhammer search --in title "Advanced Code Review"
</code></pre>
<h4 id="exploring-available-prompts"><a class="header" href="#exploring-available-prompts">Exploring Available Prompts</a></h4>
<pre><code class="language-bash"># See all available prompts
swissarmyhammer search --limit 50 ""

# Browse by category/topic
swissarmyhammer search documentation
swissarmyhammer search testing
swissarmyhammer search refactoring

# Find simple prompts (no arguments)
swissarmyhammer search --no-args
</code></pre>
<h4 id="finding-template-examples"><a class="header" href="#finding-template-examples">Finding Template Examples</a></h4>
<pre><code class="language-bash"># Find prompts using loops
swissarmyhammer search --in content "{% for"

# Find prompts with conditionals
swissarmyhammer search --in content "{% if"

# Find prompts using specific filters
swissarmyhammer search --in content "| capitalize"
</code></pre>
<h3 id="search-optimization"><a class="header" href="#search-optimization">Search Optimization</a></h3>
<h4 id="performance-tips-1"><a class="header" href="#performance-tips-1">Performance Tips</a></h4>
<pre><code class="language-bash"># Limit results for faster response
swissarmyhammer search --limit 10 query

# Use specific fields to reduce search scope
swissarmyhammer search --in title query  # faster than all fields

# Use source filtering to narrow search space
swissarmyhammer search --source user query
</code></pre>
<h4 id="precision-vs-recall"><a class="header" href="#precision-vs-recall">Precision vs. Recall</a></h4>
<pre><code class="language-bash"># High precision (exact matches)
swissarmyhammer search --case-sensitive --regex "^exact pattern$"

# High recall (find everything related)
swissarmyhammer search --in all "broad topic"

# Balanced approach
swissarmyhammer search "specific terms" --limit 20
</code></pre>
<h2 id="integration-with-other-commands-1"><a class="header" href="#integration-with-other-commands-1">Integration with Other Commands</a></h2>
<h3 id="search-and-test-workflow"><a class="header" href="#search-and-test-workflow">Search and Test Workflow</a></h3>
<pre><code class="language-bash"># Find debugging prompts
swissarmyhammer search debug

# Test a specific one
swissarmyhammer test debug-helper

# Test with specific arguments
swissarmyhammer test debug-helper --arg error="TypeError: undefined"
</code></pre>
<h3 id="search-and-export-workflow"><a class="header" href="#search-and-export-workflow">Search and Export Workflow</a></h3>
<pre><code class="language-bash"># Find all review-related prompts
swissarmyhammer search review --limit 20

# Export specific ones found
swissarmyhammer export code-review security-review design-review output.tar.gz

# Or export all matching a pattern
# (manual selection based on search results)
</code></pre>
<h3 id="scripted-search"><a class="header" href="#scripted-search">Scripted Search</a></h3>
<pre><code class="language-bash">#!/bin/bash
# find-and-test.sh

QUERY="$1"
if [ -z "$QUERY" ]; then
    echo "Usage: $0 &lt;search-query&gt;"
    exit 1
fi

echo "Searching for: $QUERY"
PROMPTS=$(swissarmyhammer search --json "$QUERY" | jq -r '.results[].id')

if [ -z "$PROMPTS" ]; then
    echo "No prompts found"
    exit 1
fi

echo "Found prompts:"
echo "$PROMPTS"

echo "Select a prompt to test:"
select PROMPT in $PROMPTS; do
    if [ -n "$PROMPT" ]; then
        swissarmyhammer test "$PROMPT"
        break
    fi
done
</code></pre>
<h2 id="json-output-for-scripting"><a class="header" href="#json-output-for-scripting">JSON Output for Scripting</a></h2>
<h3 id="basic-json-search"><a class="header" href="#basic-json-search">Basic JSON Search</a></h3>
<pre><code class="language-bash">swissarmyhammer search --json "code review"
</code></pre>
<pre><code class="language-json">{
  "query": "code review",
  "total_found": 3,
  "results": [
    {
      "id": "code-review",
      "title": "Code Review Helper",
      "description": "Review code for best practices and potential issues",
      "source": "builtin",
      "path": "/builtin/review/code.md",
      "arguments": [
        {"name": "code", "required": true},
        {"name": "language", "required": false, "default": "auto-detect"}
      ],
      "score": 0.95
    }
  ]
}
</code></pre>
<h3 id="processing-json-results"><a class="header" href="#processing-json-results">Processing JSON Results</a></h3>
<pre><code class="language-bash"># Extract prompt IDs
swissarmyhammer search --json query | jq -r '.results[].id'

# Get highest scoring result
swissarmyhammer search --json query | jq -r '.results[0].id'

# Filter by score threshold
swissarmyhammer search --json query | jq '.results[] | select(.score &gt; 0.8)'

# Count results by source
swissarmyhammer search --json "" --limit 100 | jq '.results | group_by(.source) | map({source: .[0].source, count: length})'
</code></pre>
<h2 id="search-index-management"><a class="header" href="#search-index-management">Search Index Management</a></h2>
<h3 id="understanding-the-search-index"><a class="header" href="#understanding-the-search-index">Understanding the Search Index</a></h3>
<p>SwissArmyHammer automatically maintains a search index that includes:</p>
<ul>
<li><strong>Prompt titles</strong> - Weighted heavily in scoring</li>
<li><strong>Descriptions</strong> - Medium weight</li>
<li><strong>Content text</strong> - Lower weight</li>
<li><strong>Argument names</strong> - Considered for relevance</li>
<li><strong>File paths</strong> - Used for source filtering</li>
</ul>
<h3 id="index-updates"><a class="header" href="#index-updates">Index Updates</a></h3>
<p>The search index is automatically updated when:</p>
<ul>
<li>Prompts are added to the library</li>
<li>Existing prompts are modified</li>
<li>The <code>serve</code> command starts (full rebuild)</li>
<li>File watching detects changes</li>
</ul>
<h3 id="performance-characteristics"><a class="header" href="#performance-characteristics">Performance Characteristics</a></h3>
<ul>
<li><strong>Index size</strong>: Proportional to prompt collection size</li>
<li><strong>Search speed</strong>: Sub-second for collections up to 10,000 prompts</li>
<li><strong>Memory usage</strong>: Moderate (index kept in memory)</li>
<li><strong>Update speed</strong>: Fast incremental updates</li>
</ul>
<h2 id="troubleshooting-search-issues"><a class="header" href="#troubleshooting-search-issues">Troubleshooting Search Issues</a></h2>
<h3 id="no-results-found"><a class="header" href="#no-results-found">No Results Found</a></h3>
<pre><code class="language-bash"># Check if prompts exist
swissarmyhammer search --limit 100 ""

# Verify prompt sources
swissarmyhammer search --source builtin
swissarmyhammer search --source user
swissarmyhammer search --source local

# Try broader search
swissarmyhammer search --in all "partial terms"
</code></pre>
<h3 id="too-many-results"><a class="header" href="#too-many-results">Too Many Results</a></h3>
<pre><code class="language-bash"># Use more specific terms
swissarmyhammer search "specific exact phrase"

# Limit by source
swissarmyhammer search broad-term --source user

# Use field-specific search
swissarmyhammer search --in title specific-title

# Limit result count
swissarmyhammer search broad-term --limit 5
</code></pre>
<h3 id="unexpected-results"><a class="header" href="#unexpected-results">Unexpected Results</a></h3>
<pre><code class="language-bash"># Check what's being matched
swissarmyhammer search --full query

# Use exact matching
swissarmyhammer search --regex "^exact term$"

# Search in specific field
swissarmyhammer search --in description query
</code></pre>
<h2 id="best-practices-2"><a class="header" href="#best-practices-2">Best Practices</a></h2>
<h3 id="effective-search-terms"><a class="header" href="#effective-search-terms">Effective Search Terms</a></h3>
<ol>
<li><strong>Use specific terms</strong>: ‚ÄúREST API documentation‚Äù vs. ‚ÄúAPI‚Äù</li>
<li><strong>Include context</strong>: ‚ÄúPython debugging‚Äù vs. ‚Äúdebugging‚Äù</li>
<li><strong>Try synonyms</strong>: ‚Äúreview‚Äù, ‚Äúanalyze‚Äù, ‚Äúexamine‚Äù</li>
<li><strong>Use argument names</strong>: Search for ‚Äúcode‚Äù, ‚Äúerror‚Äù, ‚Äúdata‚Äù to find relevant prompts</li>
</ol>
<h3 id="search-workflow-patterns"><a class="header" href="#search-workflow-patterns">Search Workflow Patterns</a></h3>
<ol>
<li><strong>Start broad, narrow down</strong>: Begin with general terms, add filters</li>
<li><strong>Use multiple strategies</strong>: Try both fuzzy and regex search</li>
<li><strong>Check all sources</strong>: Don‚Äôt assume prompts are only in one location</li>
<li><strong>Combine with testing</strong>: Always test prompts before using</li>
</ol>
<h3 id="organization-for-searchability"><a class="header" href="#organization-for-searchability">Organization for Searchability</a></h3>
<ol>
<li><strong>Clear titles</strong>: Use descriptive, searchable titles</li>
<li><strong>Good descriptions</strong>: Include keywords and use cases</li>
<li><strong>Consistent naming</strong>: Use standard terms across prompts</li>
<li><strong>Tag with arguments</strong>: Use predictable argument names</li>
</ol>
<h2 id="advanced-examples"><a class="header" href="#advanced-examples">Advanced Examples</a></h2>
<h3 id="finding-template-patterns"><a class="header" href="#finding-template-patterns">Finding Template Patterns</a></h3>
<pre><code class="language-bash"># Find prompts using custom filters
swissarmyhammer search --in content "format_lang"

# Find prompts with error handling
swissarmyhammer search --in content "default:"

# Find prompts with loops
swissarmyhammer search --in content "{% for"
</code></pre>
<h3 id="building-prompt-collections"><a class="header" href="#building-prompt-collections">Building Prompt Collections</a></h3>
<pre><code class="language-bash"># Find all code-related prompts
swissarmyhammer search --regex "(code|programming|software)" --limit 50

# Find all documentation prompts
swissarmyhammer search --regex "(doc|documentation|readme|guide)" --limit 30

# Find all analysis prompts
swissarmyhammer search --regex "(analy|review|audit|inspect)" --limit 20
</code></pre>
<h3 id="quality-assurance"><a class="header" href="#quality-assurance">Quality Assurance</a></h3>
<pre><code class="language-bash"># Find prompts without descriptions
swissarmyhammer search --in description "^$" --regex

# Find prompts with no arguments (might need descriptions)
swissarmyhammer search --no-args --limit 50

# Find prompts with many arguments (might be complex)
swissarmyhammer search --json "" --limit 100 | \
  jq '.results[] | select(.arguments | length &gt; 5)'
</code></pre>
<h2 id="see-also-5"><a class="header" href="#see-also-5">See Also</a></h2>
<ul>
<li><a href="./cli-search.html"><code>search</code> command</a> - Command reference</li>
<li><a href="./cli-test.html"><code>test</code> command</a> - Testing found prompts</li>
<li><a href="./prompt-organization.html">Prompt Organization</a> - Organizing for discoverability</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing-and-debugging-guide"><a class="header" href="#testing-and-debugging-guide">Testing and Debugging Guide</a></h1>
<p>This guide covers testing strategies, debugging techniques, and best practices for working with SwissArmyHammer prompts.</p>
<h2 id="interactive-testing-1"><a class="header" href="#interactive-testing-1">Interactive Testing</a></h2>
<h3 id="basic-testing-workflow"><a class="header" href="#basic-testing-workflow">Basic Testing Workflow</a></h3>
<p>The <code>test</code> command provides an interactive environment for testing prompts:</p>
<pre><code class="language-bash"># Start interactive testing
swissarmyhammer test code-review
</code></pre>
<p>This will:</p>
<ol>
<li>Load the specified prompt</li>
<li>Prompt for required arguments</li>
<li>Show optional arguments with defaults</li>
<li>Render the template</li>
<li>Display the result</li>
<li>Offer additional actions (copy, save, retry)</li>
</ol>
<h3 id="testing-with-predefined-arguments"><a class="header" href="#testing-with-predefined-arguments">Testing with Predefined Arguments</a></h3>
<pre><code class="language-bash"># Test with known arguments
swissarmyhammer test code-review \
  --arg code="fn main() { println!(\"Hello\"); }" \
  --arg language="rust"

# Copy result directly to clipboard
swissarmyhammer test email-template \
  --arg recipient="John" \
  --arg subject="Meeting" \
  --copy
</code></pre>
<h2 id="debugging-template-issues"><a class="header" href="#debugging-template-issues">Debugging Template Issues</a></h2>
<h3 id="common-template-problems"><a class="header" href="#common-template-problems">Common Template Problems</a></h3>
<h4 id="missing-variables"><a class="header" href="#missing-variables">Missing Variables</a></h4>
<pre><code class="language-liquid">&lt;!-- Problem: undefined variable --&gt;
Hello {{name}}

&lt;!-- Solution: provide default --&gt;
Hello {{ name | default: "Guest" }}
</code></pre>
<h4 id="type-mismatches"><a class="header" href="#type-mismatches">Type Mismatches</a></h4>
<pre><code class="language-liquid">&lt;!-- Problem: trying to use string methods on numbers --&gt;
{{ count | upcase }}

&lt;!-- Solution: convert types --&gt;
{{ count | append: " items" }}
</code></pre>
<h4 id="loop-issues"><a class="header" href="#loop-issues">Loop Issues</a></h4>
<pre><code class="language-liquid">&lt;!-- Problem: not checking for empty arrays --&gt;
{% for item in items %}
  - {{ item }}
{% endfor %}

&lt;!-- Solution: check array exists and has items --&gt;
{% if items and items.size &gt; 0 %}
  {% for item in items %}
    - {{ item }}
  {% endfor %}
{% else %}
  No items found.
{% endif %}
</code></pre>
<h3 id="debug-mode-1"><a class="header" href="#debug-mode-1">Debug Mode</a></h3>
<p>Use debug mode to see detailed template processing:</p>
<pre><code class="language-bash">swissarmyhammer test prompt-name --debug
</code></pre>
<p>Debug output includes:</p>
<ul>
<li>Variable resolution steps</li>
<li>Filter application results</li>
<li>Conditional evaluation</li>
<li>Loop iteration details</li>
<li>Performance timing</li>
</ul>
<h2 id="validation-strategies"><a class="header" href="#validation-strategies">Validation Strategies</a></h2>
<h3 id="argument-validation"><a class="header" href="#argument-validation">Argument Validation</a></h3>
<p>Test with different argument combinations:</p>
<pre><code class="language-bash"># Test required arguments only
swissarmyhammer test prompt-name --arg required_arg="value"

# Test with all arguments
swissarmyhammer test prompt-name \
  --arg required_arg="value" \
  --arg optional_arg="optional_value"

# Test with edge cases
swissarmyhammer test prompt-name \
  --arg text="" \
  --arg number="0" \
  --arg array="[]"
</code></pre>
<h3 id="template-edge-cases"><a class="header" href="#template-edge-cases">Template Edge Cases</a></h3>
<p>Create test cases for common scenarios:</p>
<ol>
<li><strong>Empty inputs</strong></li>
<li><strong>Very long inputs</strong></li>
<li><strong>Special characters</strong></li>
<li><strong>Unicode content</strong></li>
<li><strong>Null/undefined values</strong></li>
</ol>
<h3 id="automated-testing"><a class="header" href="#automated-testing">Automated Testing</a></h3>
<p>For prompt libraries, create test scripts:</p>
<pre><code class="language-bash">#!/bin/bash
# test-all-prompts.sh

PROMPTS=$(swissarmyhammer search --json "" --limit 100 | jq -r '.results[].id')

for prompt in $PROMPTS; do
    echo "Testing $prompt..."
    if swissarmyhammer test "$prompt" --arg placeholder="test" 2&gt;/dev/null; then
        echo "‚úì $prompt"
    else
        echo "‚úó $prompt"
    fi
done
</code></pre>
<h2 id="performance-testing"><a class="header" href="#performance-testing">Performance Testing</a></h2>
<h3 id="measuring-render-time"><a class="header" href="#measuring-render-time">Measuring Render Time</a></h3>
<pre><code class="language-bash"># Time a complex template
time swissarmyhammer test complex-template \
  --arg large_data="$(cat large-file.json)"

# Use debug mode for detailed timing
swissarmyhammer test template-name --debug | grep "Performance:"
</code></pre>
<h3 id="memory-usage-testing"><a class="header" href="#memory-usage-testing">Memory Usage Testing</a></h3>
<p>For large templates or data:</p>
<pre><code class="language-bash"># Monitor memory usage during rendering
/usr/bin/time -v swissarmyhammer test large-template \
  --arg big_data="$(cat massive-dataset.json)"
</code></pre>
<h2 id="best-practices-3"><a class="header" href="#best-practices-3">Best Practices</a></h2>
<h3 id="writing-testable-prompts"><a class="header" href="#writing-testable-prompts">Writing Testable Prompts</a></h3>
<ol>
<li><strong>Provide sensible defaults</strong> for optional arguments</li>
<li><strong>Handle empty/null inputs</strong> gracefully</li>
<li><strong>Use meaningful argument names</strong></li>
<li><strong>Include example values</strong> in descriptions</li>
<li><strong>Test with realistic data sizes</strong></li>
</ol>
<h3 id="testing-workflow"><a class="header" href="#testing-workflow">Testing Workflow</a></h3>
<ol>
<li><strong>Start simple</strong>: Test with minimal arguments</li>
<li><strong>Add complexity</strong>: Test with full argument sets</li>
<li><strong>Test edge cases</strong>: Empty, null, large inputs</li>
<li><strong>Validate output</strong>: Ensure rendered content makes sense</li>
<li><strong>Performance check</strong>: Verify reasonable render times</li>
</ol>
<h3 id="debugging-tips"><a class="header" href="#debugging-tips">Debugging Tips</a></h3>
<ol>
<li><strong>Use debug mode</strong> for complex templates</li>
<li><strong>Test filters individually</strong> in simple templates</li>
<li><strong>Validate JSON/YAML</strong> with external tools</li>
<li><strong>Check argument types</strong> match expectations</li>
<li><strong>Use raw mode</strong> to see unprocessed templates</li>
</ol>
<h2 id="integration-with-development"><a class="header" href="#integration-with-development">Integration with Development</a></h2>
<h3 id="ide-integration"><a class="header" href="#ide-integration">IDE Integration</a></h3>
<p>Many editors support SwissArmyHammer testing:</p>
<pre><code class="language-bash"># VS Code task example
{
  "version": "2.0.0",
  "tasks": [
    {
      "label": "Test Current Prompt",
      "type": "shell",
      "command": "swissarmyhammer",
      "args": ["test", "${fileBasenameNoExtension}"],
      "group": "test",
      "presentation": {
        "echo": true,
        "reveal": "always",
        "focus": false,
        "panel": "shared"
      }
    }
  ]
}
</code></pre>
<h3 id="continuous-integration-1"><a class="header" href="#continuous-integration-1">Continuous Integration</a></h3>
<p>Add prompt testing to CI pipelines:</p>
<pre><code class="language-yaml"># .github/workflows/test-prompts.yml
name: Test Prompts
on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Install SwissArmyHammer
        run: cargo install --git https://github.com/wballard/swissarmyhammer.git swissarmyhammer-cli
      - name: Test all prompts
        run: |
          for prompt in prompts/*.md; do
            name=$(basename "$prompt" .md)
            echo "Testing $name..."
            swissarmyhammer test "$name" --arg test="ci_validation"
          done
</code></pre>
<h2 id="see-also-6"><a class="header" href="#see-also-6">See Also</a></h2>
<ul>
<li><a href="./cli-test.html"><code>test</code> command</a> - Command reference</li>
<li><a href="./template-variables.html">Template Variables</a> - Template syntax</li>
<li><a href="./custom-filters.html">Custom Filters</a> - Filter reference</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sharing-and-collaboration"><a class="header" href="#sharing-and-collaboration">Sharing and Collaboration</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mcp-protocol"><a class="header" href="#mcp-protocol">MCP Protocol</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuration-1"><a class="header" href="#configuration-1">Configuration</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="file-watching-1"><a class="header" href="#file-watching-1">File Watching</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prompt-overrides"><a class="header" href="#prompt-overrides">Prompt Overrides</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="built-in-prompts"><a class="header" href="#built-in-prompts">Built-in Prompts</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-filters-reference-1"><a class="header" href="#custom-filters-reference-1">Custom Filters Reference</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="examples-5"><a class="header" href="#examples-5">Examples</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="troubleshooting-3"><a class="header" href="#troubleshooting-3">Troubleshooting</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributing"><a class="header" href="#contributing">Contributing</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="development-setup"><a class="header" href="#development-setup">Development Setup</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing-1"><a class="header" href="#testing-1">Testing</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="release-process"><a class="header" href="#release-process">Release Process</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="changelog"><a class="header" href="#changelog">Changelog</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="license-1"><a class="header" href="#license-1">License</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
