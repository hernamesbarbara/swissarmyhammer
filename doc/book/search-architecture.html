<!DOCTYPE HTML>
<html lang="en" class="navy sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Search Architecture - SwissArmyHammer Documentation</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Complete guide to using SwissArmyHammer - the MCP server for managing prompts">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "navy";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('navy')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">SwissArmyHammer Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/wballard/swissarmyhammer" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/wballard/swissarmyhammer/edit/main/doc/src/src/search-architecture.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="search-architecture"><a class="header" href="#search-architecture">Search Architecture</a></h1>
<p>SwissArmyHammer implements a multi-tiered search architecture that combines traditional text search with modern semantic search capabilities. This document provides a deep dive into the search system’s architecture, indexing strategies, and performance characteristics.</p>
<h2 id="architecture-overview"><a class="header" href="#architecture-overview">Architecture Overview</a></h2>
<pre><code>┌─────────────────────────────────────────────────────────────┐
│                     Search Frontend                        │
├─────────────────────────────────────────────────────────────┤
│  CLI Interface    │  MCP Server    │  Library API          │
└─────────────────────┬───────────────┬─────────────────────────┘
                      │               │
┌─────────────────────┴───────────────┴─────────────────────────┐
│                   Search Engine                             │
├─────────────────────────────────────────────────────────────┤
│  Hybrid Search Controller                                   │
│  ├─ Query Routing Logic                                     │
│  ├─ Result Aggregation                                      │
│  └─ Score Normalization                                     │
└─────────────────────┬───────────────┬─────────────────────────┘
                      │               │
┌─────────────────────┴───────────────┴─────────────────────────┐
│               Search Backends                               │
├─────────────────────────────────────────────────────────────┤
│  Fuzzy Search     │  Full-Text      │  Semantic Search       │
│  (SkimMatcher)    │  (Tantivy)      │  (Embeddings+DuckDB)   │
└─────────────────────┬───────────────┬─────────────────────────┘
                      │               │
┌─────────────────────┴───────────────┴─────────────────────────┐
│                 Storage Layer                               │
├─────────────────────────────────────────────────────────────┤
│  In-Memory        │  File System    │  Vector Database       │
│  (RAM Index)      │  (Persistent)   │  (DuckDB + VSS)        │
└─────────────────────────────────────────────────────────────┘
</code></pre>
<h2 id="search-engines"><a class="header" href="#search-engines">Search Engines</a></h2>
<h3 id="1-fuzzy-search-engine"><a class="header" href="#1-fuzzy-search-engine">1. Fuzzy Search Engine</a></h3>
<p><strong>Implementation</strong>: <code>search.rs::SearchEngine::fuzzy_search</code></p>
<p><strong>Technology Stack</strong>:</p>
<ul>
<li><strong>Matcher</strong>: <code>skim_matcher_v2</code> (fuzzy string matching)</li>
<li><strong>Storage</strong>: In-memory prompt collection</li>
<li><strong>Indexing</strong>: None (searches on-demand)</li>
</ul>
<p><strong>Architecture</strong>:</p>
<pre><code class="language-rust">pub struct SearchEngine {
    fuzzy_matcher: SkimMatcherV2,
    // Other fields...
}</code></pre>
<p><strong>Performance Characteristics</strong>:</p>
<ul>
<li><strong>Time Complexity</strong>: O(n*m) where n=prompts, m=avg prompt length</li>
<li><strong>Space Complexity</strong>: O(1) additional memory</li>
<li><strong>Latency</strong>: 1-5ms for typical collections</li>
<li><strong>Strengths</strong>: Fast, handles typos, no indexing overhead</li>
<li><strong>Weaknesses</strong>: No semantic understanding, limited scalability</li>
</ul>
<h3 id="2-full-text-search-engine"><a class="header" href="#2-full-text-search-engine">2. Full-Text Search Engine</a></h3>
<p><strong>Implementation</strong>: <code>search.rs::SearchEngine::search</code></p>
<p><strong>Technology Stack</strong>:</p>
<ul>
<li><strong>Search Engine</strong>: Apache Tantivy</li>
<li><strong>Storage</strong>: RAM index with optional persistence</li>
<li><strong>Query Language</strong>: Lucene-compatible syntax</li>
</ul>
<p><strong>Architecture</strong>:</p>
<pre><code class="language-rust">pub struct SearchEngine {
    index: Index,
    writer: IndexWriter,
    name_field: Field,
    description_field: Field,
    category_field: Field,
    tags_field: Field,
    template_field: Field,
}</code></pre>
<p><strong>Index Schema</strong>:</p>
<ul>
<li><code>name</code>: Prompt name (TEXT | STORED)</li>
<li><code>description</code>: Prompt description (TEXT | STORED)</li>
<li><code>category</code>: Prompt category (TEXT | STORED)</li>
<li><code>tags</code>: Space-separated tags (TEXT | STORED)</li>
<li><code>template</code>: Prompt content (TEXT only)</li>
</ul>
<p><strong>Performance Characteristics</strong>:</p>
<ul>
<li><strong>Indexing</strong>: O(n log n) build time, O(log n) updates</li>
<li><strong>Query</strong>: O(log n) typical case</li>
<li><strong>Memory</strong>: ~50MB writer buffer + index size</li>
<li><strong>Strengths</strong>: Boolean queries, exact matching, fast retrieval</li>
<li><strong>Weaknesses</strong>: No semantic understanding, requires exact terms</li>
</ul>
<h3 id="3-semantic-search-engine"><a class="header" href="#3-semantic-search-engine">3. Semantic Search Engine</a></h3>
<p><strong>Implementation</strong>: <code>semantic/</code> modules</p>
<p><strong>Technology Stack</strong>:</p>
<ul>
<li><strong>Embeddings</strong>: ONNX Runtime with transformer models</li>
<li><strong>Vector Storage</strong>: DuckDB with vector similarity search extension</li>
<li><strong>Code Parsing</strong>: TreeSitter multi-language parser</li>
<li><strong>File Processing</strong>: Async I/O with tokio</li>
</ul>
<p><strong>Architecture</strong>:</p>
<pre><code class="language-rust">pub struct SemanticSearcher {
    storage: VectorStorage,
    embedding_engine: EmbeddingEngine,
    config: SemanticConfig,
}

pub struct VectorStorage {
    db: Connection,
    embeddings_table: String,
    chunks_table: String,
}

pub struct EmbeddingEngine {
    session: Session,
    tokenizer: Tokenizer,
    model_config: ModelConfig,
}</code></pre>
<p><strong>Database Schema</strong>:</p>
<pre><code class="language-sql">-- Code chunks table
CREATE TABLE chunks (
    id TEXT PRIMARY KEY,
    file_path TEXT NOT NULL,
    content TEXT NOT NULL,
    language TEXT,
    start_line INTEGER,
    end_line INTEGER,
    chunk_type TEXT,
    created_at TIMESTAMP DEFAULT now()
);

-- Vector embeddings table
CREATE TABLE embeddings (
    chunk_id TEXT PRIMARY KEY,
    embedding FLOAT[],
    embedding_model TEXT,
    created_at TIMESTAMP DEFAULT now(),
    FOREIGN KEY (chunk_id) REFERENCES chunks(id)
);
</code></pre>
<p><strong>Performance Characteristics</strong>:</p>
<ul>
<li><strong>Indexing</strong>: O(n*k) where k=embedding dimension (384-1536)</li>
<li><strong>Query</strong>: O(n) similarity calculation with HNSW optimization</li>
<li><strong>Memory</strong>: Model size (100MB-2GB) + embeddings cache</li>
<li><strong>Strengths</strong>: Semantic understanding, cross-language search</li>
<li><strong>Weaknesses</strong>: High memory usage, slower than text search</li>
</ul>
<h2 id="indexing-strategies"><a class="header" href="#indexing-strategies">Indexing Strategies</a></h2>
<h3 id="text-index-management"><a class="header" href="#text-index-management">Text Index Management</a></h3>
<p><strong>Index Creation</strong>:</p>
<pre><code class="language-rust">// In-memory index (default)
let engine = SearchEngine::new()?;

// Persistent index
let engine = SearchEngine::with_directory("/path/to/index")?;</code></pre>
<p><strong>Index Updates</strong>:</p>
<ul>
<li><strong>Incremental</strong>: Add/remove individual prompts</li>
<li><strong>Batch</strong>: Bulk updates with commit optimization</li>
<li><strong>Rebuild</strong>: Full index reconstruction</li>
</ul>
<p><strong>Index Persistence</strong>:</p>
<ul>
<li>Memory-mapped files for fast loading</li>
<li>Atomic commits to prevent corruption</li>
<li>Configurable buffer sizes for performance tuning</li>
</ul>
<h3 id="vector-index-management"><a class="header" href="#vector-index-management">Vector Index Management</a></h3>
<p><strong>Embedding Generation</strong>:</p>
<pre><code class="language-rust">// Code chunk processing pipeline
CodeFile -&gt; TreeSitter Parse -&gt; Chunks -&gt; Embeddings -&gt; Storage</code></pre>
<p><strong>Vector Storage</strong>:</p>
<ul>
<li><strong>Chunking Strategy</strong>: Function/class-level granularity</li>
<li><strong>Embedding Models</strong>: Configurable ONNX models</li>
<li><strong>Similarity Metrics</strong>: Cosine similarity (default)</li>
<li><strong>Index Types</strong>: HNSW for approximate nearest neighbor</li>
</ul>
<p><strong>Update Strategies</strong>:</p>
<ul>
<li><strong>Lazy Updates</strong>: Generate embeddings on first search</li>
<li><strong>Eager Updates</strong>: Pre-compute all embeddings</li>
<li><strong>Incremental</strong>: Update only changed files</li>
</ul>
<h2 id="query-processing-pipeline"><a class="header" href="#query-processing-pipeline">Query Processing Pipeline</a></h2>
<h3 id="1-query-analysis"><a class="header" href="#1-query-analysis">1. Query Analysis</a></h3>
<pre><code class="language-rust">enum QueryType {
    Simple(String),
    Regex(String),
    Boolean(BooleanQuery),
    Semantic(SemanticQuery),
}</code></pre>
<h3 id="2-strategy-selection"><a class="header" href="#2-strategy-selection">2. Strategy Selection</a></h3>
<pre><code class="language-rust">impl SearchEngine {
    fn select_strategy(&amp;self, query: &amp;Query) -&gt; SearchStrategy {
        match query {
            Query { regex: true, .. } =&gt; SearchStrategy::Regex,
            Query { semantic: true, .. } =&gt; SearchStrategy::Semantic,
            Query { fuzzy: true, .. } =&gt; SearchStrategy::Fuzzy,
            _ =&gt; SearchStrategy::Hybrid,
        }
    }
}</code></pre>
<h3 id="3-result-aggregation"><a class="header" href="#3-result-aggregation">3. Result Aggregation</a></h3>
<pre><code class="language-rust">pub fn hybrid_search(&amp;self, query: &amp;str, prompts: &amp;[Prompt]) -&gt; Result&lt;Vec&lt;SearchResult&gt;&gt; {
    let mut results = HashMap::new();
    
    // Combine multiple search strategies
    let text_results = self.search(query, prompts)?;
    let fuzzy_results = self.fuzzy_search(query, prompts);
    
    // Merge and deduplicate results
    // Score normalization and ranking
    
    Ok(final_results)
}</code></pre>
<h2 id="performance-optimization"><a class="header" href="#performance-optimization">Performance Optimization</a></h2>
<h3 id="caching-strategies"><a class="header" href="#caching-strategies">Caching Strategies</a></h3>
<p><strong>Query Result Caching</strong>:</p>
<ul>
<li>LRU cache for frequent queries</li>
<li>TTL-based invalidation</li>
<li>Configurable cache size limits</li>
</ul>
<p><strong>Index Caching</strong>:</p>
<ul>
<li>Memory-mapped index files</li>
<li>Lazy loading of index segments</li>
<li>Background index warming</li>
</ul>
<p><strong>Embedding Caching</strong>:</p>
<ul>
<li>Persistent embedding storage</li>
<li>Model result caching</li>
<li>Batch processing optimization</li>
</ul>
<h3 id="memory-management"><a class="header" href="#memory-management">Memory Management</a></h3>
<p><strong>Memory Usage Patterns</strong>:</p>
<pre><code>Component               | Memory Usage
------------------------|----------------------------------
Fuzzy Search           | O(1) - no additional memory
Full-Text Index        | O(index_size) ~ 10-20% of data
Semantic Embeddings    | O(chunks * dimensions) ~ 1-5GB
Model Loading          | 100MB - 2GB depending on model
Result Sets            | O(result_count * prompt_size)
</code></pre>
<p><strong>Optimization Strategies</strong>:</p>
<ul>
<li>Stream processing for large result sets</li>
<li>Configurable result limits</li>
<li>Memory-mapped storage for large indices</li>
<li>Model quantization for embedding models</li>
</ul>
<h3 id="performance-tuning"><a class="header" href="#performance-tuning">Performance Tuning</a></h3>
<p><strong>Configuration Parameters</strong>:</p>
<pre><code class="language-rust">pub struct SearchConfig {
    // Full-text search
    pub tantivy_writer_buffer_size: usize,
    pub tantivy_merge_policy: MergePolicy,
    
    // Semantic search
    pub embedding_batch_size: usize,
    pub similarity_threshold: f32,
    pub max_results_per_query: usize,
    
    // Hybrid search
    pub score_combination_strategy: ScoreStrategy,
    pub result_deduplication: bool,
}</code></pre>
<p><strong>Benchmarking Results</strong>:</p>
<pre><code>Search Type     | Latency (p50) | Latency (p99) | Throughput
----------------|---------------|---------------|------------
Fuzzy Search    | 2ms          | 8ms           | 500 qps
Full-Text       | 5ms          | 15ms          | 200 qps
Semantic        | 50ms         | 150ms         | 20 qps
Hybrid          | 25ms         | 80ms          | 40 qps
</code></pre>
<h2 id="scalability-considerations"><a class="header" href="#scalability-considerations">Scalability Considerations</a></h2>
<h3 id="data-size-limits"><a class="header" href="#data-size-limits">Data Size Limits</a></h3>
<p><strong>Recommended Limits</strong>:</p>
<ul>
<li><strong>Prompts</strong>: Up to 100,000 prompts</li>
<li><strong>Code Files</strong>: Up to 1 million files</li>
<li><strong>Index Size</strong>: Up to 10GB total</li>
<li><strong>Concurrent Users</strong>: Up to 100 simultaneous searches</li>
</ul>
<h3 id="scaling-strategies"><a class="header" href="#scaling-strategies">Scaling Strategies</a></h3>
<p><strong>Horizontal Scaling</strong>:</p>
<ul>
<li>Distributed search with result merging</li>
<li>Sharded indices by category/source</li>
<li>Load balancing across search nodes</li>
</ul>
<p><strong>Vertical Scaling</strong>:</p>
<ul>
<li>Memory optimization for large datasets</li>
<li>SSD storage for persistent indices</li>
<li>GPU acceleration for semantic search</li>
</ul>
<h2 id="integration-points"><a class="header" href="#integration-points">Integration Points</a></h2>
<h3 id="mcp-server-integration"><a class="header" href="#mcp-server-integration">MCP Server Integration</a></h3>
<pre><code class="language-rust">pub struct McpSearchHandler {
    search_engine: Arc&lt;SearchEngine&gt;,
    semantic_searcher: Arc&lt;SemanticSearcher&gt;,
}</code></pre>
<h3 id="cli-integration"><a class="header" href="#cli-integration">CLI Integration</a></h3>
<pre><code class="language-rust">pub async fn handle_search_command(
    args: SearchArgs,
    prompt_library: &amp;PromptLibrary,
) -&gt; Result&lt;()&gt; {
    // Route to appropriate search engine
    // Format results for terminal display
}</code></pre>
<h3 id="library-api"><a class="header" href="#library-api">Library API</a></h3>
<pre><code class="language-rust">pub trait SearchProvider {
    fn search(&amp;self, query: &amp;SearchQuery) -&gt; Result&lt;Vec&lt;SearchResult&gt;&gt;;
    fn suggest(&amp;self, partial: &amp;str) -&gt; Result&lt;Vec&lt;String&gt;&gt;;
    fn similar(&amp;self, item_id: &amp;str) -&gt; Result&lt;Vec&lt;SearchResult&gt;&gt;;
}</code></pre>
<h2 id="future-enhancements"><a class="header" href="#future-enhancements">Future Enhancements</a></h2>
<h3 id="planned-features"><a class="header" href="#planned-features">Planned Features</a></h3>
<ul>
<li><strong>Vector Database</strong>: Migration to specialized vector DB (Qdrant/Weaviate)</li>
<li><strong>Hybrid Retrieval</strong>: BM25 + vector search combination</li>
<li><strong>Query Expansion</strong>: Automatic query term expansion</li>
<li><strong>Personalization</strong>: User-specific result ranking</li>
<li><strong>Real-time Updates</strong>: Streaming index updates</li>
</ul>
<h3 id="research-directions"><a class="header" href="#research-directions">Research Directions</a></h3>
<ul>
<li><strong>Multi-modal Embeddings</strong>: Code + documentation + comments</li>
<li><strong>Graph-based Search</strong>: Code dependency graph traversal</li>
<li><strong>Federated Search</strong>: Cross-repository search capabilities</li>
<li><strong>Explainable Rankings</strong>: Search result explanations</li>
</ul>
<h2 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h2>
<h3 id="common-issues"><a class="header" href="#common-issues">Common Issues</a></h3>
<p><strong>Index Corruption</strong>:</p>
<pre><code class="language-bash"># Rebuild text index
rm -rf ~/.swissarmyhammer/index
swissarmyhammer search --rebuild-index

# Rebuild semantic index
swissarmyhammer search --rebuild-embeddings
</code></pre>
<p><strong>Memory Issues</strong>:</p>
<pre><code class="language-bash"># Reduce memory usage
export SWISSARMYHAMMER_MAX_RESULTS=100
export SWISSARMYHAMMER_EMBEDDING_BATCH_SIZE=10
</code></pre>
<p><strong>Performance Problems</strong>:</p>
<pre><code class="language-bash"># Enable search timing
swissarmyhammer search --timing "query"

# Profile search performance
swissarmyhammer search --profile "detailed query"
</code></pre>
<h3 id="monitoring"><a class="header" href="#monitoring">Monitoring</a></h3>
<p><strong>Metrics to Track</strong>:</p>
<ul>
<li>Query latency percentiles</li>
<li>Index size growth</li>
<li>Memory usage patterns</li>
<li>Cache hit rates</li>
<li>Error rates by search type</li>
</ul>
<p><strong>Logging Configuration</strong>:</p>
<pre><code class="language-rust">// Enable debug logging for search
RUST_LOG=swissarmyhammer::search=debug cargo run</code></pre>
<h2 id="see-also"><a class="header" href="#see-also">See Also</a></h2>
<ul>
<li><a href="./search-guide.html">Search Guide</a> - User guide for search features</li>
<li><a href="./cli-search.html">CLI Search Reference</a> - Command-line interface</li>
<li><a href="./performance.html">Performance Tuning</a> - Optimization guidelines</li>
<li><a href="./index-management.html">Index Management</a> - Index maintenance guide</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="search-guide.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="index-management.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="search-guide.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="index-management.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
