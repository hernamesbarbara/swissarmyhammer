# Step 151: Add Issue Update and Move Operations

## Goal
Implement operations to update issue content and move issues between pending and completed states, ensuring atomic file operations and proper error handling.

## Implementation Details

### 1. Add Update Operation to IssueStorage Trait

```rust
pub trait IssueStorage: Send + Sync {
    // ... existing methods ...
    
    /// Update an existing issue's content
    async fn update_issue(&self, number: u32, content: String) -> Result<Issue>;
    
    /// Mark an issue as complete (move to complete directory)
    async fn mark_complete(&self, number: u32) -> Result<Issue>;
}
```

### 2. Implement Update Operation

```rust
impl FileSystemIssueStorage {
    /// Update issue content
    async fn update_issue_impl(&self, number: u32, content: String) -> Result<Issue> {
        // Find the issue file (check both directories)
        // Read current issue to preserve metadata
        // Write new content to file
        // Return updated Issue struct
        
        let issue = self.get_issue(number).await?;
        let path = &issue.file_path;
        
        // Atomic write using temp file and rename
        let temp_path = path.with_extension("tmp");
        std::fs::write(&temp_path, &content)?;
        std::fs::rename(&temp_path, path)?;
        
        Ok(Issue {
            content,
            ..issue
        })
    }
}
```

### 3. Implement Move Operation

```rust
impl FileSystemIssueStorage {
    /// Move issue between directories
    async fn move_issue(&self, number: u32, to_completed: bool) -> Result<Issue> {
        // Find current issue
        let mut issue = self.get_issue(number).await?;
        
        // Check if already in target state
        if issue.completed == to_completed {
            return Ok(issue);
        }
        
        // Determine source and target paths
        let target_dir = if to_completed {
            &self.state.completed_dir
        } else {
            &self.state.issues_dir
        };
        
        // Create target path with same filename
        let filename = issue.file_path.file_name()
            .ok_or_else(|| /* error */)?;
        let target_path = target_dir.join(filename);
        
        // Move file atomically
        std::fs::rename(&issue.file_path, &target_path)?;
        
        // Update issue struct
        issue.file_path = target_path;
        issue.completed = to_completed;
        
        Ok(issue)
    }
}
```

### 4. Implement IssueStorage Methods

```rust
impl IssueStorage for FileSystemIssueStorage {
    async fn update_issue(&self, number: u32, content: String) -> Result<Issue> {
        self.update_issue_impl(number, content).await
    }
    
    async fn mark_complete(&self, number: u32) -> Result<Issue> {
        self.move_issue(number, true).await
    }
}
```

### 5. Add Helper Method for Checking Completion Status

```rust
impl FileSystemIssueStorage {
    /// Check if all issues are completed
    pub async fn all_complete(&self) -> Result<bool> {
        let pending_count = self.list_issues_in_dir(&self.state.issues_dir)?
            .into_iter()
            .filter(|issue| !issue.completed)
            .count();
        
        Ok(pending_count == 0)
    }
}
```

## Error Handling
- Handle file not found gracefully
- Handle permission errors
- Ensure atomic operations (no partial states)
- Rollback on failure where possible

## Testing
- Test updating issue content
- Test moving issue to completed
- Test moving already completed issue (should be no-op)
- Test concurrent access scenarios
- Test error cases (missing files, permission errors)
- Test all_complete with various states

## Success Criteria
- Issues can be updated without data loss
- Issues can be moved between states atomically
- Proper error handling for edge cases
- No race conditions in file operations