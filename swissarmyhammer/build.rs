use std::env;
use std::fs;
use std::path::Path;

fn main() {
    // Tell Cargo to re-run this build script if the prompts directory changes
    println!("cargo:rerun-if-changed=../builtin/prompts");
    // Tell Cargo to re-run this build script if the workflows directory changes
    println!("cargo:rerun-if-changed=../builtin/workflows");

    let out_dir = env::var("OUT_DIR").unwrap();

    // Generate builtin prompts
    generate_builtin_prompts(&out_dir);

    // Generate builtin workflows
    generate_builtin_workflows(&out_dir);
}

fn generate_builtin_prompts(out_dir: &str) {
    let dest_path = Path::new(&out_dir).join("builtin_prompts.rs");

    // Get the manifest directory (where Cargo.toml is located)
    let manifest_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
    let builtin_dir = Path::new(&manifest_dir).join("../builtin/prompts");

    let mut code = String::new();
    code.push_str("// Auto-generated builtin prompts - do not edit manually\n");
    code.push_str("// Generated by build.rs from builtin/prompts directory\n\n");
    code.push_str("/// Get all built-in prompts as a vector of (name, content) tuples\n");
    code.push_str("pub fn get_builtin_prompts() -> Vec<(&'static str, &'static str)> {\n");
    code.push_str("    vec![\n");

    if builtin_dir.exists() {
        collect_prompts(&builtin_dir, "", &mut code);
    }

    code.push_str("    ]\n");
    code.push_str("}\n");

    fs::write(&dest_path, code).unwrap();
}

fn generate_builtin_workflows(out_dir: &str) {
    let dest_path = Path::new(&out_dir).join("builtin_workflows.rs");

    // Get the manifest directory (where Cargo.toml is located)
    let manifest_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
    let builtin_dir = Path::new(&manifest_dir).join("../builtin/workflows");

    let mut code = String::new();
    code.push_str("// Auto-generated builtin workflows - do not edit manually\n");
    code.push_str("// Generated by build.rs from builtin/workflows directory\n\n");
    code.push_str("/// Get all built-in workflows as a vector of (name, content) tuples\n");
    code.push_str("pub fn get_builtin_workflows() -> Vec<(&'static str, &'static str)> {\n");
    code.push_str("    vec![\n");

    if builtin_dir.exists() {
        collect_workflows(&builtin_dir, "", &mut code);
    }

    code.push_str("    ]\n");
    code.push_str("}\n");

    fs::write(&dest_path, code).unwrap();
}

fn collect_prompts(dir: &Path, prefix: &str, code: &mut String) {
    if let Ok(entries) = fs::read_dir(dir) {
        let mut entries: Vec<_> = entries.collect();
        entries.sort_by_key(|entry| entry.as_ref().unwrap().path());

        for entry in entries.into_iter().flatten() {
            let path = entry.path();
            let name = path.file_name().unwrap().to_string_lossy();

            if path.is_dir() {
                // Skip the workflows directory as these are workflow definitions, not regular prompts
                if name == "workflows" {
                    continue;
                }
                // Recursively collect from subdirectories
                let new_prefix = if prefix.is_empty() {
                    name.to_string()
                } else {
                    format!("{}/{}", prefix, name)
                };
                collect_prompts(&path, &new_prefix, code);
            } else if name.ends_with(".md") || name.ends_with(".liquid") {
                // Generate the prompt name
                let prompt_name = if prefix.is_empty() {
                    name.strip_suffix(".md")
                        .or_else(|| name.strip_suffix(".liquid"))
                        .unwrap_or(&name)
                        .to_string()
                } else {
                    format!(
                        "{}/{}",
                        prefix,
                        name.strip_suffix(".md")
                            .or_else(|| name.strip_suffix(".liquid"))
                            .unwrap_or(&name)
                    )
                };

                // Read the file content at build time and embed it as a string literal
                if let Ok(content) = fs::read_to_string(&path) {
                    code.push_str(&format!(
                        "        (\"{}\", r#\"{}\"#),\n",
                        prompt_name, content
                    ));
                }
            }
        }
    }
}

fn collect_workflows(dir: &Path, prefix: &str, code: &mut String) {
    if let Ok(entries) = fs::read_dir(dir) {
        let mut entries: Vec<_> = entries.collect();
        entries.sort_by_key(|entry| entry.as_ref().unwrap().path());

        for entry in entries.into_iter().flatten() {
            let path = entry.path();
            let name = path.file_name().unwrap().to_string_lossy();

            if path.is_dir() {
                // Recursively collect from subdirectories
                let new_prefix = if prefix.is_empty() {
                    name.to_string()
                } else {
                    format!("{}/{}", prefix, name)
                };
                collect_workflows(&path, &new_prefix, code);
            } else if name.ends_with(".md") {
                // Generate the workflow name
                let workflow_name = if prefix.is_empty() {
                    name.strip_suffix(".md").unwrap_or(&name).to_string()
                } else {
                    format!("{}/{}", prefix, name.strip_suffix(".md").unwrap_or(&name))
                };

                // Read the file content at build time and embed it as a string literal
                if let Ok(content) = fs::read_to_string(&path) {
                    code.push_str(&format!(
                        "        (\"{}\", r#\"{}\"#),\n",
                        workflow_name, content
                    ));
                }
            }
        }
    }
}
